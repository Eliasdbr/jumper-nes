                                
                                ;	Jumper (main.asm)
                                ;	por Eliasdbr (eliasdbr@outlook.com)
                                ;	***Escrito para ASM6 v1.6***
                                
                                ; Definiciones del proyecto
                                .include "src/init.asm"
                                ;
                                ;	Jumper (init.asm)
                                ;	Establece definiciones del proyecto
                                ;	por Eliasdbr (eliasdbr@outlook.com)
                                ;	Para la NES/Famicom
                                ;	***Escrito para ASM6 v1.6***
                                
                                ;	Consumo de recursos
                                ;	RAM: 8 bytes
                                ;	ROM: -
                                
                                ;;	DEFINICIONES
                                TRUE		EQU 1
                                FALSE 	EQU 0
                                NULL		EQU 0
                                
                                NTSC		EQU 0
                                PAL 		EQU 1
                                
                                SYS_REGION = 0 	; Región del sistema.
                                
                                ; PLACEHOLDERS PARA EL ENSAMBLADOR
                                ; Estas variables del ensamblador guardarán las direcciones 
                                ; actuales de cada área para poder definir variables continuamente
                                ; entre diferentes archivos de ASM.
                                ASM_ZEROPAGE= 		$0000 	;Página Cero (Zero Page)
                                ASM_DATASEGMENT=	$0300 	;Segmento de Datos (Data Segment) (Empieza la RAM)
                                ASM_PROGRAM=			$8000 	;Programa (PRG-ROM)
                                
                                ; Variables de uso intensivo (8 bytes)
                                .enum ASM_ZEROPAGE
00000                           temp0 		.byte 0 	;Variables temporales
00001                           temp1 		.byte 0 	;(generalmente usadas para las funciones)
00002                           temp2 		.byte 0 	
00003                           temp3 		.byte 0 	
00004                           temp4 		.byte 0 	
00005                           temp5 		.byte 0 	
00006                           temp6 		.byte 0 	
00007                           temp7 		.byte 0 	
00008                           ASM_ZEROPAGE = $
00008                           .ende
                                
                                ;;	MACROS
                                ; MANIPULACIÓN DE DATOS.
                                .macro LoadAXY ra,rx,ry 	; Carga los registros A,X,Y 	(Especificar address mode)
                                	lda ra
                                	ldx rx
                                	ldy ry
                                .endm
                                	
                                .macro LoadXY rx,ry 	; Carga los registros X,Y (Especificar address mode)
                                	ldx rx
                                	ldy ry
                                .endm
                                
                                .macro MemCopy from,to		; Copia un byte desde una posición de memoria a otra. (Especificar address mode)
                                	lda from
                                	sta to
                                .endm
                                
                                .macro MemCopy2 from1,from2,to1,to2 	; Copia 2 bytes. Cada origen con su destino. (Especificar address mode)
                                	ldx from1
                                	ldy from2
                                	stx to1
                                	sty to2
                                .endm
                                
                                .macro MemBulkCopy from,to,amount			; Copia <amount> bytes. Amount debe ser entre 1 y 256 inclusive (Especificar address mode)
                                	ldx #amount-1
                                	-
                                		lda from,x
                                		sta to,x
                                		dex
                                	bne -
                                .endm
                                
                                .macro PushAXY		; Empuja los registros A,X,Y a la pila.
                                	pha
                                	txa
                                	pha
                                	tya
                                	pha
                                .endm
                                
                                .macro PullAXY		; Saca los registros A,X,Y de la pila.
                                	pla
                                	tay
                                	pla
                                	tax
                                	pla
                                .endm
                                
                                ; PROCESAMIENTO DE DATOS.
                                .macro Sign number	; Obtiene el signo de un número. (<0 = -1; 0 = 0, >0 = 1)	(Especificar address mode)
                                	lda number					; carga en A un número
                                	beq @end						; Si es 0, devuelve 0 en A.
                                	bmi @negative 			; Si es negativo, devuelve -1.
                                	lda #1							; si es positivo, devuelve 1.
                                	bpl @end						; termina.
                                	@negative:					; 
                                	lda #-1 						; 
                                	@end: 							; fin del macro
                                .endm
                                
                                .macro Opposite number	; Devuelve en A el complemento a 2 de un número.
                                	lda number
                                	eor #$FF
                                	tax
                                	inx
                                	txa
                                .endm
                                
                                .macro Abs number	; Devuelve en A el valor absoluto de un número.
                                	lda number
                                	bpl @end
                                	Opposite number
                                	@end:
                                .endm
                                
                                .macro Max n1,n2	; Devuelve en A el Máximo de 2 números. 	(Especificar address mode)
                                	lda n1
                                	cmp n2
                                	bpl @end
                                	lda n2
                                	@end:
                                .endm
                                
                                .macro Min n1,n2	; Devuelve en A el Mínimo de 2 números. 	(Especificar address mode)
                                	lda n1
                                	cmp n2
                                	bmi @end
                                	lda n2
                                	@end:
                                .endm
                                
                                .macro ToFixed8 number	; Convierte un número con signo de 8 bits en un número de punto fijo de 8 bits (SIIIFFFF)
                                	;Si el numero es <(-8) o >(+7), devuelve error. ($FF en X)
                                	lda number
                                	cmp #-8
                                	bmi @error
                                	cmp #7
                                	bpl @error
                                	asl
                                	asl			;Corre el número 4 bits a la izquierda (A*16)
                                	asl
                                	asl
                                	jmp @end
                                	@error:
                                	ldx #$FF
                                	@end:
                                .endm
                                
                                ; Incluye el header del archivo
                                .include "lib/header_ines.asm"			; Formato iNES
                                ;
                                ;	ines_header.asm
                                ;	por Eliasdbr (eliasdbr@outlook.com)
                                ;	Para la NES/Famicom
                                ;	***Escrito para ASM6 v1.6***
                                
                                ;	NOTAS:
                                ;	-Está todo hardcodeado, hay que generalizar junto con "init.asm"
                                
                                	; # - - - - - - - - - - - - #
                                	; # - - - iNES header - - - #
                                	; # - - - - - - - - - - - - #
                                
                                ; iNES identifier
      4E 45 53 1A               .byte "NES",$1a
                                
                                ; Cantidad de Bloques de Programa (PRG-ROM x 16kB)(byte 4)
      02                        .byte $02		;2x16kB = 32kB total
                                
                                ; Cantidad de Bloques Gráficos (CHR-ROM x 8kB)(byte 5)
      01                        .byte $01
                                
                                ; Información de control del ROM (bytes 6-7)
      01 00                     .byte %00000001 , $00
                                ;< MMMMvtbm , MMMM---- >
                                ;	M = 8 bits para determinar qué Mapper se usa. 0 = NROM (sin Mapper)
                                ;	v =	No reflejar las "nametables", usar VRAM incorporada para almacenar 4 "nametables" diferentes.
                                ;	t = Usar un "Trainer" de 512 bytes antes del PRG-ROM. (Tiene algo que ver con los Mappers)
                                ;	b = Usar RAM alimentada con Batería(PRG-RAM).
                                ;	m = Reflejar las 2 "nametables" verticalmente? 0 = Horizontalmente, 1 = Verticalmente
                                ;	- = Otros flags para control de ROM que yo dejo en 0 (para más info buscar "iNES Header")
                                
                                ; Tamaño de la RAM alimentada por batería (PRG-RAM) (byte 8)
      00                        .byte $00	;yo no lo uso, así que 0.
                                
                                ; Región de TV (byte 9)
      00                        .byte $00	;0 = NTSC(América del norte, Japon, Oeste de Sudamérica) 
                                			;1 = PAL(Europa, Este de Sudamérica)
                                			; ***Algunos emuladores usan el bit 1 del BYTE 10 para esto
                                
                                ; Relleno (bytes 10-15)
      00 00 00 00 00 00         .byte $00,$00,$00,$00,$00,$00
                                
                                
                                .org ASM_PROGRAM										; Comienza a ensamblar código
08000                           
08000                           ; Incluir librerías
08000                           .include "lib/nes_ppu.asm"					; Manejo de gráficos
08000                           ;
08000                           ;	Librería que maneja la PPU (nes_ppu.asm)
08000                           ;	por Eliasdbr (eliasdbr@outlook.com)
08000                           ;	Para la NES/Famicom 
08000                           ;	***Escrito para ASM6 v1.6***
08000                           
08000                           	; # - - - - - - - - - - - - - - - - - - - #
08000                           	; # - - - Constantes del Assembler  - - - #
08000                           	; # - - - - - - - - - - - - - - - - - - - #
08000                           
08000                           ;;	REGRISTROS DE LA PPU
08000                           PPUCTRL= $2000			;PPU Control Register
08000                           PPUMASK= $2001			;PPU Mask Register
08000                           PPUSTAT= $2002			;PPU Status Register
08000                           OAMADDR= $2003			;PPU OAM Address
08000                           OAMDATA= $2004			;PPU OAM Data
08000                           PPUSCRL= $2005			;PPU Fine Scroll (two writes= X, Y)
08000                           PPUADDR= $2006			;PPU Address
08000                           PPUDATA= $2007			;PPU Data
08000                           OAMDMA=  $4014			;OAM DMA Page (parte alta)
08000                           
08000                           ;;	DIRECCIONES DENTRO DE LA PPU
08000                           PPUNAM0 = $2000		;PPU Name Table 0
08000                           PPUNAM1 = $2400		;PPU Name Table 1
08000                           PPUNAM2 = $2800		;PPU Name Table 2
08000                           PPUNAM3 = $2C00		;PPU Name Table 3
08000                           PPUPAL	= $3F00		;PPU Palettes
08000                           
08000                           ;;	DIRECCIONES GENERALES
08000                           OAM_PAGE= $0200		;dirección donde empieza la tabla de objetos(sprites)
08000                           
08000                           ;;	FLAGS
08000                           ;PPU Control ($2000) write
08000                           PPUCTRL_NMI_ENABLE 	= $80	; Permite a la PPU activar el interrupt NMI
08000                           PPUCTRL_MASTER	   	= $40	; Siempre poner en 0. Inútil si la consola no está hackeada.
08000                           PPUCTRL_8X16_SPR	= $20	; 0: utiliza sprites de 8x8. 1: Utiliza sprites de 8x16
08000                           PPUCTRL_BG_PATTERN	= $10	; Ubicación de los tiles de fondo en CHR-ROM. 0: $0000. 1: $1000.
08000                           PPUCTRL_SPR_PATTERN	= $08	; Ubicación de los tiles de sprites en CHR-ROM. 0: $0000. 1: $1000.
08000                           PPUCTRL_ADDR_INC	= $04	; Cantidad que incrementa PPUADDR por cada lectura/escritura del CPU. 0: +1. 1: +32
08000                           ;PPU Mask ($2001) write
08000                           PPUMASK_EMPHASIZE_BLUE 	= $80			; Enfatiza el color azul
08000                           if SYS_REGION==0						; Dependiendo de la Región(NTSC o PAL), se define las flags de red y green
08000                           	PPUMASK_EMPHASIZE_GREEN = $40		;  Enfatiza el color verde
08000                           	PPUMASK_EMPHASIZE_RED	= $20		;  Enfatiza el color rojo
08000                           else
08000                           	PPUMASK_EMPHASIZE_RED 	= $40
08000                           	PPUMASK_EMPHASIZE_GREEN	= $20
08000                           endif
08000                           PPUMASK_SHOW_SPR		= $10			; Mostrar sprites.
08000                           PPUMASK_SHOW_BG 		= $08			; Mostrar Fondo.
08000                           PPUMASK_LEFTMOST_SPR	= $04			; Mostrar los primeros 8 píxeles desde la izquierda (sprites).
08000                           PPUMASK_LEFTMOST_BG 	= $02			; Mostrar los primeros 8 píxeles desde la izquierda (fondo).
08000                           PPUMASK_GRAYSCALE		= $01			; Modo blanco y negro.
08000                           ;PPU Status ($2002) read
08000                           PPUSTAT_VBLANK = $80		; VBlank ha comenzado
08000                           PPUSTAT_SPR0_HIT = $40		; Sprite 0 Hit. Se usa para interrupts a mitad del frame
08000                           PPUSTAT_SPR_LIMIT = $20		; Sprite Overflow. Inestable, no tiene utilidad.
08000                           
08000                           ;Sprite Attributes
08000                           SPRATTR_VFLIP= %10000000		;Atributo del sprite: Voltear verticalmente
08000                           SPRATTR_HFLIP= %01000000		;Atributo del sprite: Voltear horizontalmente
08000                           SPRATTR_BEHIND= %00100000		;Atributo del sprite: Detrás del Fondo
08000                           
08000                           ;Sprite Info Offsets
08000                           SPRINFO_Y = 0 		; Posición Y
08000                           SPRINFO_TILE = 1	; Tile del Sprite
08000                           SPRINFO_ATTR = 2	; Atributos del sprite
08000                           SPRINFO_X = 3 		; Posición X
08000                           
08000                           ;;	VARIABLES
08000                           .enum ASM_ZEROPAGE				;- - Variables de uso intensivo - -
00008                           ; 2 bytes
00008                           scroll_x		.byte 0		;Posición x de la cámara
00009                           scroll_y		.byte 0		;Posición y de la cámara
0000A                           
0000A                           ASM_ZEROPAGE = $					;
0000A                           .ende						;- - Fin de reserva de variables - -
08000                           
08000                           ; # - - - - - - - - - - - - - - #
08000                           ; # - - - 	MACROS	 	  - - - #
08000                           ; # - - - - - - - - - - - - - - #
08000                           ;;	Activar el PPU con los parámetros establecidos
08000                           .macro PPU_Enable control,mask
08000                           	lda #control
08000                           	sta PPUCTRL
08000                           	lda #mask
08000                           	sta PPUMASK
08000                           .endm
08000                           
08000                           ;;	Desactivar el PPU
08000                           .macro PPU_Disable
08000                           	lda #0
08000                               sta PPUCTRL  ; disable NMI
08000                               sta PPUMASK  ; disable rendering
08000                           .endm
08000                           
08000                           ;;	Inicializa la tabla de sprites
08000                           .macro PPU_InitOAM
08000                           	lda #$FF
08000                           	ldx #$00
08000                           -	sta OAM_PAGE,x
08000                           	inx
08000                           	bne -
08000                           .endm
08000                           
08000                           ;;	Actualiza el Scroll del Fondo
08000                           .macro PPU_ScrollUpdate
08000                           	ldx scroll_x
08000                           	ldy scroll_y
08000                           	stx PPUSCRL
08000                           	sty PPUSCRL
08000                           .endm
08000                           
08000                           ; # - - - - - - - - - - - - - - - - - - - - #
08000                           ; # - - - Sub-Rutinas (Funciones) 	  - - - #
08000                           ; # - - - - - - - - - - - - - - - - - - - - #
08000                           .base ASM_PROGRAM
08000                           	
08000                           ;	CARGA UN SPRITE EN LA TABLA OAM		Parámetros: ypos,tile,attributes,xpos
08000                           ;	Parámetros:
08000                           ;		A: Sprite ID (0-63)
08000                           ;		X: puntero del sprite a copiar (byte bajo)
08000                           ;		Y: puntero del sprite a copiar (byte alto)
08000                           ;	Ocupa:
08000                           ;		temp0: puntero del sprite a copiar (byte bajo)
08000                           ;		temp1: puntero del sprite a copiar (byte alto)
08000                           PPU_loadSprite:
08000                           	spr_data = temp0	; Utiliza las variables temp0 y temp1 para almacenar la dirección del sprite.
08000                           
08000 86 00                     	stx spr_data		; transfiere la dirección del sprite de origen
08002 84 01                     	sty spr_data+1		; a la página cero liberando así los registros X,Y.
08004                           	
08004 0A                        	asl					; 
08005 0A                        	asl					; X = A * 4		// Transforma el ID del Sprite en un offset de la Tabla de sprites
08006 AA                        	tax					; 	
08007 A0 00                     	ldy #0				; Y = 0			// Usará Y como puntero de propiedades del sprite
08009                           	
08009 B1 00                     -	lda (spr_data),y	; Copia la propiedad del sprite de origen
0800B 9D 00 02                  	sta OAM_PAGE,x	; La pega en el offset de la Tabla de sprites
0800E E8                        	inx					;
0800F C8                        	iny					; Pasa a la siguiente propiedad
08010 C0 04                     	cpy #4				; 
08012 D0 F5                     	bne -				; Hacer lo mismo con las 4 propiedades
08014                           	
08014 60                        	rts					; fin de sub-rutina
08015                           
08015                           ;	CARGA UNA PALETA (16 colores)
08015                           ;	Parámetros:
08015                           ;		A: Offset de dirección de paleta (0 = Background; 16 = Sprites)
08015                           ;		X: puntero de la paleta a copiar (byte bajo)
08015                           ;		Y: puntero de la paleta a copiar (byte alto)
08015                           ;	Ocupa:
08015                           ;		temp0: puntero de la paleta a copiar (byte bajo)
08015                           ;		temp1: puntero de la paleta a copiar (byte alto)
08015                           PPU_loadPalette:
08015                           	pal_data = temp0 	; Utiliza las variables temp0 y temp1 para almacenar la dirección de la paleta.
08015                           	
08015 86 00                     	stx pal_data		; transfiere la dirección de la paleta de origen
08017 84 01                     	sty pal_data+1		; a la página cero, liberando así los registros X,Y
08019                           	
08019 A2 3F                     	ldx #>PPUPAL		; Dirección de las paletas dentro de la memoria de la PPU.
0801B 8E 06 20                  	stx PPUADDR			; El CPU le avisa a la PPU que le va a enviar
0801E 8D 06 20                  	sta PPUADDR			; datos a esa dirección de su memoria (PPUPAL) (byte alto, byte bajo)
08021                           	
08021 A0 00                     	ldy #0				; Y = 0.
08023 B1 00                     -	lda (pal_data),y	; Copia esos datos desde pal_data
08025 8D 07 20                  	sta PPUDATA			; Los envía uno por uno
08028 C8                        	iny					; pasa al siguiente
08029 C0 10                     	cpy #$10			; 
0802B D0 F6                     	bne -				; Si llegó a los 16 colores, termina.
0802D                           	
0802D 60                        	rts					; Fin de la sub-rutina.
0802E                           
0802E                           ;	CARGA UNA PANTALLA EN EL NAMETABLE DETERMINADO (0-3)
0802E                           ;	Parámetros:
0802E                           ;		A: Nametable (0 - 3)
0802E                           ;		X: puntero de la pantalla a copiar (byte bajo)
0802E                           ;		Y: puntero de la pantalla a copiar (byte alto)
0802E                           ;	Ocupa:
0802E                           ;		temp0: puntero de la pantalla a copiar (byte bajo)
0802E                           ;		temp1: puntero de la pantalla a copiar (byte alto)
0802E                           PPU_loadScreen:
0802E                           	scr_data = temp0	; puntero de la pantalla a copiar
0802E 86 00                     	stx scr_data			; Escribe la dirección de la pantalla a copiar
08030 84 01                     	sty scr_data+1		; en temp0 (parte baja) y temp1 (parte alta) Libera X, Y.
08032                           	
08032 0A                        	asl 					; A *= 4	// Convierte el N° de nametable en su offset				A | PPUADDR
08033 0A                        	asl 					; 				// correspondiente dentro de la memoria de la ppu. ---+---------
08034 18                        	clc 					; 																														0 | $2000
08035 69 20                     	adc #>PPUNAM0		; Agrega el offset a la dirección de la nametable.					1 | $2400
08037 A2 00                     	ldx #0				; X = 0.																											2 | $2800
08039 8D 06 20                  	sta PPUADDR			; El CPU le avisa a la PPU que le va a enviar 							3 | $2C00
0803C 8E 06 20                  	stx PPUADDR			; datos a esa dirección de su memoria (PPUNAMx)
0803F                           	
0803F A0 00                     	ldy #0				; Y = 0
08041 A2 04                     	ldx #4				; X = 4	// X cuenta las páginas que quedan copiar de la pantalla (4 * 256 = 1024 bytes)
08043 B1 00                     -	lda (scr_data),y	; Copia esos datos desde scr_data
08045 8D 07 20                  	sta PPUDATA			; Los envía uno por uno.
08048 C8                        	iny					; Pasa al siguiente.
08049 D0 F8                     	bne -				; Si no completó una página, vuelve a enviar otro byte. 
0804B E6 01                     	inc scr_data+1		; Pasa a la siguiente página de 256 bytes.
0804D CA                        	dex					;
0804E D0 F3                     	bne -				; Si el contador X no llegó a 0, quedan páginas por copiar.
08050                           	
08050 60                        	rts					; Fin de la sub-rutina.
08051                           
08051                           ; Fin del código
08051                           ASM_PROGRAM = $
08051                           .include "lib/nes_interrupts.asm" 	; Interrupts RESET,NMI,IRQ
08051                           ;
08051                           ;	Interrupciones del Hardware
08051                           ;	por Eliasdbr (eliasdbr@outlook.com)
08051                           ;	Para la NES/Famicom 
08051                           ;	***Escrito para ASM6 v1.6***
08051                           
08051                           ;;	CONSTANTES
08051                           
08051                           
08051                           ;;	VARIABLES
08051                           .enum ASM_ZEROPAGE			;- - Variables de uso intensivo - -
0000A                           ; 1 byte
0000A                           waiting_nmi		.byte 0		;flag para determinar si se debe esperar al NMI
0000B                           
0000B                           ASM_ZEROPAGE = $			;
0000B                           .ende						;- - Fin de reserva de variables - -
08051                           
08051                           ;;	MACROS
08051                           
08051                           
08051                           ; # - - - - - - - - - - - - - - - - - - - - #
08051                           ; # - - - Código ubicado en la ROM 	  - - - #
08051                           ; # - - - - - - - - - - - - - - - - - - - - #
08051                           .base ASM_PROGRAM
08051                           ;A partir de aquí escribiremos el programa que se ejecutará al Encender/Resetear la consola.
08051                           RESET:
08051 78                            sei        ; ignore IRQs
08052 D8                            cld        ; disable decimal mode
08053 A2 40                         ldx #$40
08055 8E 17 40                      stx $4017  ; disable APU frame IRQ
08058 A2 FF                         ldx #$ff
0805A 9A                            txs        ; Set up stack
0805B                           	
0805B                           	; Desactiva los gráficos
0805B                               PPU_Disable	0	;es un macro.
0805B A9 00                     	lda #0
0805D 8D 00 20                      sta PPUCTRL  ; disable NMI
08060 8D 01 20                      sta PPUMASK  ; disable rendering
08063                           
08063                               ; Optional (omitted):
08063                               ; Set up mapper and jmp to further init code here.
08063                           
08063                               ; The vblank flag is in an unknown state after reset,
08063                               ; so it is cleared here to make sure that @vblankwait1
08063                               ; does not exit immediately.
08063 2C 02 20                      bit $2002
08066                           
08066                               ; First of two waits for vertical blank to make sure that the
08066                               ; PPU has stabilized
08066                           @vblankwait1:  
08066 2C 02 20                      bit $2002
08069 10 FB                         bpl @vblankwait1
0806B                           
0806B                               ; We now have about 30,000 cycles to burn before the PPU stabilizes.
0806B                               ; One thing we can do with this time is put RAM in a known state.
0806B                               ; Here we fill it with $00, which matches what (say) a C compiler
0806B                               ; expects for BSS.  Conveniently, X is still 0.
0806B 8A                            txa
0806C                           @clrmem:
0806C 95 00                         sta $000,x
0806E 9D 00 01                      sta $100,x
08071 9D 00 02                      sta $200,x
08074 9D 00 03                      sta $300,x
08077 9D 00 04                      sta $400,x
0807A 9D 00 05                      sta $500,x
0807D 9D 00 06                      sta $600,x
08080 9D 00 07                      sta $700,x
08083 E8                            inx
08084 D0 E6                         bne @clrmem
08086                           	
08086                               ; Other things you can do between vblank waits are set up audio
08086                               ; or set up other mapper registers.
08086                              
08086                           @vblankwait2:
08086 2C 02 20                      bit $2002
08089 10 FB                         bpl @vblankwait2
0808B                           
0808B                           	PPU_InitOAM 	;Limpia la memoria de sprites (es un macro)
0808B A9 FF                     	lda #$FF
0808D A2 00                     	ldx #$00
0808F 9D 00 02                  -	sta OAM_PAGE,x
08092 E8                        	inx
08093 D0 FA                     	bne -
08095                           	
08095                           	; LO QUE VIENE ES SÓLO DE JUMPER
08095                           	; Carga el sprite de Ogmo
08095 A2 A0                     	ldx #<sprite_ogmo	;byte bajo
08097 A0 8F                     	ldy #>sprite_ogmo	;byte alto
08099 A9 01                     	lda #1				;ID del Sprite 1
0809B 20 00 80                  	jsr PPU_loadSprite
0809E                           	
0809E                           	; Carga el sprite de Ogmo Azul
0809E A2 A0                     	ldx #<sprite_ogmo	;byte bajo
080A0 A0 8F                     	ldy #>sprite_ogmo	;byte alto
080A2 A9 02                     	lda #2				;ID del Sprite 2
080A4 20 00 80                  	jsr PPU_loadSprite
080A7                           	; Igual a Ogmo, sólo que con la paleta azul
080A7 A9 03                     	lda #3
080A9 8D 0A 02                  	sta OAM_PAGE+2*4+2	; Sprite 2, atributos
080AC                           	
080AC                           	; Carga la paleta del fondo
080AC A2 80                     	ldx #<palette	;dirección byte bajo
080AE A0 8F                     	ldy #>palette	;dirección byte alto
080B0 A9 00                     	lda #0			;A=0 -> Paleta del Fondo
080B2 20 15 80                  	jsr PPU_loadPalette
080B5                           	
080B5                           	; Carga la paleta de sprites
080B5 A2 90                     	ldx #<(palette+16)	;dirección byte bajo
080B7 A0 8F                     	ldy #>palette		;dirección byte alto
080B9 A9 10                     	lda #16				;A=16 -> Paleta de Sprites
080BB 20 15 80                  	jsr PPU_loadPalette
080BE                           	
080BE                           	; FIN DEL CÓDIGO DE JUMPER
080BE                           	
080BE                           	; Activar Vblank NMI, Sprites: $0000, Fondo: $1000
080BE                           	ctrl_flags = PPUCTRL_NMI_ENABLE | PPUCTRL_BG_PATTERN
080BE                           	; Muestra los sprites y el fondo
080BE                           	mask_flags = PPUMASK_SHOW_SPR | PPUMASK_SHOW_BG
080BE                           	; Reactiva los gráficos
080BE                           	PPU_Enable ctrl_flags,mask_flags		;es un macro.
080BE A9 90                     	lda #ctrl_flags
080C0 8D 00 20                  	sta PPUCTRL
080C3 A9 18                     	lda #mask_flags
080C5 8D 01 20                  	sta PPUMASK
080C8                           
080C8                           	;Otra instrucción que requiere la consola, iría al finalizar la preparación del juego.
080C8 58                        	cli		;Permitir IRQs
080C9                           	
080C9                           	; Fin de la inicialización
080C9 4C AA 84                  	jmp main_setup		;salta al arranque del juego
080CC                           
080CC                           ; # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
080CC                           ; # - - - VBLANK (ya se dibujó el frame anterior. preparar el que sigue   - - - #
080CC                           ; # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
080CC                           ; Nota: colocar aquí SÓLO la info para actualizar gráficos, ya que el tiempo que disponemos para 
080CC                           ;		hacerlo es relativamente corto, así que todo lo que tenga que ver con las mecánicas y la
080CC                           ;		lógica del juego debe ir más arriba(en la parte de loop principal del juego).
080CC                           NMI:
080CC                           	PushAXY		; Macro. Llevamos los registros del procesador a la pila (A,X,Y)
080CC 48                        	pha
080CD 8A                        	txa
080CE 48                        	pha
080CF 98                        	tya
080D0 48                        	pha
080D1                           	; Le pasa al PPU la dirección de los sprites
080D1 A9 02                     	lda #>OAM_PAGE
080D3 8D 14 40                  	sta OAMDMA
080D6                           	; Lo último que se debe hacer antes de terminar es actualizar el valor del Scroll
080D6                           	PPU_ScrollUpdate	;Macro. obtiene las coordenadas del Scroll desde la memoria de página cero.
080D6 A6 08                     	ldx scroll_x
080D8 A4 09                     	ldy scroll_y
080DA 8E 05 20                  	stx PPUSCRL
080DD 8C 05 20                  	sty PPUSCRL
080E0                           	; La PPU ya está lista y le dice al CPU que deje de esperar
080E0 A9 00                     	lda #$00
080E2 85 0A                     	sta waiting_nmi
080E4                           	; Una vez finalizadas todas las tareas de dibujado, restauramos los registros y volvemos.
080E4                           	PullAXY		; Macro. Saca los registros A,X,Y de la pila.
080E4 68                        	pla
080E5 A8                        	tay
080E6 68                        	pla
080E7 AA                        	tax
080E8 68                        	pla
080E9 40                        	rti
080EA                           
080EA                           ; En caso de haber un IRQ, saltará acá.
080EA                           IRQ:
080EA                           	;No pasará nada
080EA 40                        	rti
080EB                           
080EB                           ASM_PROGRAM = $
080EB                           .include "lib/nes_io.asm" 					; Joypads
080EB                           ;
080EB                           ;	Librería de interfaz de usuario (joysticks)
080EB                           ;	por Eliasdbr (eliasdbr@outlook.com)
080EB                           ;	Para la NES/Famicom 
080EB                           
080EB                            
080EB                           ;
080EB                           ;	***Escrito para ASM6 v1.6***
080EB                           
080EB                           ;; CONSTANTES
080EB                           ;;	REGISTROS DEL HARDWARE
080EB                           JOYPAD1= $4016			;Joypad 1
080EB                           JOYPAD2= $4017			;Joypad 2
080EB                           
080EB                           
080EB                           ;;	FLAGS 
080EB                           JP_A=		%10000000		;Botón Joypad 'A'
080EB                           JP_B=		%01000000		;Botón Joypad 'B'
080EB                           JP_SELECT= 	%00100000		;Botón Joypad 'Select'
080EB                           JP_START=	%00010000		;Botón Joypad 'Start'
080EB                           JP_UP=		%00001000		;Botón Joypad 'Up'
080EB                           JP_DOWN=	%00000100		;Botón Joypad 'Down'
080EB                           JP_LEFT=	%00000010		;Botón Joypad 'Left'
080EB                           JP_RIGHT=	%00000001		;Botón Joypad 'Right'
080EB                           
080EB                           
080EB                           ;;	VARIABLES PÁGINA CERO
080EB                           .enum ASM_ZEROPAGE
0000B                           ; 4 bytes
0000B                           joypad1 			.byte 0		;estados de los botones del jugador 1
0000C                           joypad1_prev	.byte 0		;estado de los botones del jugador 1 en el frame anterior.
0000D                           joypad2 			.byte 0		;estados de los botones del jugador 2
0000E                           joypad2_prev	.byte 0		;estado de los botones del jugador 2 en el frame anterior. 
0000F                           
0000F                           ASM_ZEROPAGE = $
0000F                           .ende
080EB                           
080EB                           ;;	SEGMENTO DE DATOS
080EB                           ; Nada aún.
080EB                           
080EB                           ;;	MACROS
080EB                           
080EB                           ; Chequea si el botón determinado está presionado o no. (Usa A)
080EB                           ; 	player: (1,2) qué jugador chequea
080EB                           ; 	button: (flag) qué botón chequea
080EB                           ; 	justpressed: (bool) chequea si comenzó a presionarse en el frame actual
080EB                           .macro IO_CheckButton player,button,justpressed
080EB                           	lda joypad1 + (player - 1)*2
080EB                           	and #button
080EB                           	beq @end
080EB                           	IF justpressed
080EB                           		eor joypad1_prev + (player - 1)*2
080EB                           		and #button
080EB                           	ENDIF
080EB                           	@end:
080EB                           	cmp #0
080EB                           	; Regresa el estado de la flag "Zero"
080EB                           	; También deja el estado del botón en A.
080EB                           	; (A == 0: Falso -- A != 0: Verdadero)
080EB                           .endm
080EB                           ;OBTENER DATOS DE LOS CONTROLES
080EB                           .macro IO_JoyUpdate
080EB                           	; Actualiza los botones previos
080EB                           	ldx joypad1
080EB                           	ldy joypad2
080EB                           	stx joypad1_prev
080EB                           	sty joypad2_prev
080EB                           	; Actualiza los botones actuales
080EB                           	lda #$01
080EB                           	sta joypad1 	;le ponemos 1 a joypad1 para indicar cuándo llega a mirar los 8 botones.
080EB                           	sta joypad2 	; repetir con el joystick 2
080EB                           	sta JOYPAD1 	;decirle a los controles(joysticks) #1 y #2 que miren qué botones se están apretando.
080EB                           	sta JOYPAD2 	; repetir con el joystick 2
080EB                           	lda #$00
080EB                           	sta JOYPAD1 	;decirle al control(joystick) #1 que guarde lo botones que miró.
080EB                           	sta JOYPAD2 	; repetir con el joystick 2
080EB                           	; Ahora le pediremos al joystick si los botones estaban presionados o no, uno por uno.
080EB                           	clc
080EB                           	-
080EB                           	lda JOYPAD1 	;preguntamos el estado del botón actual
080EB                           	lsr 					;mete el estado del botón actual en el carry flag.
080EB                           	rol joypad1 	;pone el bit7 en el Carry y lo que estaba en el Carry lo manda al bit0
080EB                           	bcc - 				;si se obtienen los 8 botones, el carry estará en 1, si no, volvemos a pedir un boton.
080EB                           	clc 					;
080EB                           	-
080EB                           	lda JOYPAD2 	; repetir con el joystick 2
080EB                           	lsr 					;
080EB                           	rol joypad2 	;
080EB                           	bcc - 				;
080EB                           .endm
080EB                           
080EB                           ; # - - - - - - - - - - - - - - - - - - - - #
080EB                           ; # - - - Sub-Rutinas (Funciones) 	  - - - #
080EB                           ; # - - - - - - - - - - - - - - - - - - - - #
080EB                           
080EB                           ;; Agregar obtención de controles en modo seguro (DCPM)
080EB                           
080EB                           
080EB                           ;; FINALIZA DE DEFNIR SUB-RUTINAS
080EB                           .include "lib/move.asm" 						; Movimiento y posición
080EB                           ;
080EB                           ;	Librería de Movimiento de sprites (move.asm)
080EB                           ;	por Eliasdbr (eliasdbr@outlook.com)
080EB                           ;	Para la NES/Famicom 
080EB                           ;	***Escrito para ASM6 v1.6***
080EB                           ;	
080EB                           
080EB                           ;;	DEFINICIONES
080EB                           
080EB                           
080EB                           ;;	VARIABLES DE PÁGINA CERO
080EB                           
080EB                           
080EB                           ;;	OTRAS VARIABLES
080EB                           
080EB                           
080EB                           ;;	MACROS
080EB                           
080EB                           ; Suma la velocidad en un eje a la posición especificada (especificar addressing mode)
080EB                           .macro MOVE_ApplyVelocityAxis pos,vel
080EB                           	clc
080EB                           	lda pos
080EB                           	adc vel
080EB                           	sta pos
080EB                           .endm
080EB                           
080EB                           ; Suma la velocidad en un eje a la posición especificada (incluye sub-pixel) (especificar addressing mode)	
080EB                           .macro MOVE_ApplyVelocityAxisSub pos,pos_sub,vel,vel_sub
080EB                           	clc 						;
080EB                           	lda pos_sub,x 	;
080EB                           	adc vel_sub 		;
080EB                           	sta pos_sub,x 	;
080EB                           	lda pos,x 			;
080EB                           	adc vel 				;
080EB                           	sta pos,x 			;
080EB                           .endm
080EB                           
080EB                           .base ASM_PROGRAM
080EB                           ;;	SUB-RUTINAS
080EB                           
080EB                           ; Establece la velocidad en UN sólo eje (X/Y) tomando el input del Joypad (<>/^V)
080EB                           ; Parámetros:
080EB                           ;	A: Velocidad a establecer.
080EB                           ;	X: Estado de los botones del Joypad.
080EB                           ;	Y: 0: Botones < >, Botones ^ v.
080EB                           ;	temp0: byte bajo de la dirección de la posición a mover.
080EB                           ;	temp1: byte alto de la dirección de la posición a mover.
080EB                           ; Ocupa:
080EB                           ;	temp2-5: 4 bytes para tabla de velocidades (0,vel,-vel,0)
080EB                           MOVE_joyVelAxis:
080EB                           	target = temp0
080EB                           	table = temp2	
080EB 85 03                     	sta table+1		; Guarda la velocidad positiva en la tabla
080ED 49 FF                     	eor #$FF		; (convierte la velocidad en su negativo usando el complemento a 2)
080EF 85 04                     	sta table+2		; Guarda la velocidad negativa en la tabla
080F1 E6 04                     	inc table+2		; Registro A queda liberado.	
080F3 A9 00                     	lda #0			
080F5 85 02                     	sta table		; Pone el primer y último byte de table en 0.
080F7 85 05                     	sta table+3		; 
080F9                           	
080F9 8A                        	txa				; A = Botones del d-pad
080FA C0 00                     	cpy #0			; Pregunta si se está tomando los botones arriba/abajo (%00001100 del joypad)
080FC F0 02                     	beq +			; De ser así...
080FE 4A                        	lsr				; los corre 2 veces a la derecha (%00000011)
080FF 4A                        	lsr				;
08100 29 03                     +	and #3			; En cualquier caso, sólo nos interesa los 2 bits menos significativos.
08102 AA                        	tax				; almacena el resultado en X, se usará como puntero para la Tabla.
08103                           	
08103 A0 00                     	ldy #0			; Y = 0.
08105 B5 02                     	lda table,x		; Obtiene la velocidad correspondiente dependiendo de lo que se estaba presionando.
08107 91 00                     	sta (target),y 	; Guarda la velocidad en su variable
08109                           	
08109 60                        	rts				; Fin de sub-rutina
0810A                           
0810A                           ; Movimiento básico sobre UN sólo eje (X/Y) tomando el input del Joypad (<>/^V)
0810A                           ; Parámetros:
0810A                           ;	A: Velocidad a mover.
0810A                           ;	X: Estado de los botones del Joypad.
0810A                           ;	Y: 0: Botones < >, Botones ^ v.
0810A                           ;	temp0: byte bajo de la dirección de la posición a mover.
0810A                           ;	temp1: byte alto de la dirección de la posición a mover.
0810A                           ; Ocupa:
0810A                           ;	temp2-5: 4 bytes para tabla de velocidades (0,vel,-vel,0)
0810A                           MOVE_joyBasicAxis:
0810A                           	target = temp0
0810A                           	table = temp2	
0810A 85 03                     	sta table+1		; Guarda la velocidad positiva en la tabla
0810C 49 FF                     	eor #$FF		; (convierte la velocidad en su negativo usando el complemento a 2)
0810E 85 04                     	sta table+2		; Guarda la velocidad negativa en la tabla
08110 E6 04                     	inc table+2		; Registro A queda liberado.	
08112 A9 00                     	lda #0			
08114 85 02                     	sta table		; Pone el primer y último byte de table en 0.
08116 85 05                     	sta table+3		; 
08118                           	
08118 8A                        	txa				; A = Botones del d-pad
08119 C0 00                     	cpy #0			; Pregunta si se está tomando los botones arriba/abajo (%00001100 del joypad)
0811B F0 02                     	beq +			; De ser así...
0811D 4A                        	lsr				; los corre 2 veces a la derecha (%00000011)
0811E 4A                        	lsr				;
0811F 29 03                     +	and #3			; En cualquier caso, sólo nos interesa los 2 bits menos significativos.
08121 AA                        	tax				; almacena el resultado en X, se usará como puntero para la Tabla.
08122                           	
08122 A0 00                     	ldy #0			; Y = 0.
08124 18                        	clc				; Carry Bit = 0.
08125 B1 00                     	lda (target),y	; A = Posición actual del objeto a procesar pero sólo en un eje (X/Y).
08127 75 02                     	adc table,x		; Le suma su velocidad correspondiente dependiendo de lo que se estaba presionando.
08129 91 00                     	sta (target),y 	; Guarda la posición ya modificada.
0812B                           	
0812B 60                        	rts				; Fin de sub-rutina
0812C                           ; FIN DE SUB-RUTINA
0812C                           	
0812C                           ASM_PROGRAM = $
0812C                           .include "lib/collide.asm"					; Detección de colisiones
0812C                           ;
0812C                           ;	Librería para colisiones
0812C                           ;	por Eliasdbr (eliasdbr@outlook.com)
0812C                           ;	Para la NES/Famicom 
0812C                           ;	***Escrito para ASM6 v1.6***
0812C                           
0812C                           ;;	DEFINICIONES
0812C                           
0812C                           
0812C                           ;;	VARIABLES DE PÁGINA CERO
0812C                           
0812C                           
0812C                           ;;	OTRAS VARIABLES
0812C                           COLL_level_data = $0300
0812C                           
0812C                           ;;	MACROS
0812C                           ;	Detecta colisión entre dos rectángulos		(Especificar addressing mode)
0812C                           ;	Ocupa temp0-4, A,X,Y
0812C                           .macro COLL_Rect rx1,ry1,rw1,rh1,rx2,ry2,rw2,rh2
0812C                           	;Chequea colisiones en eje X
0812C                           	MemCopy2 rx1,rw1,temp0,temp1
0812C                           	MemCopy2 rx2,rw2,temp2,temp3
0812C                           	jsr COLL_rectAxis
0812C                           	beq + 										; Si no hay colisión en un eje, no habrá colisión.
0812C                           	;Chequea colisiones en eje Y
0812C                           	MemCopy2 ry1,rh1,temp0,temp1
0812C                           	MemCopy2 ry2,rh2,temp2,temp3
0812C                           	jsr COLL_rectAxis
0812C                           +
0812C                           .endm
0812C                           
0812C                           ; Consulta si un punto en X y Y colisiona con un tile en el mapa de tiles (se puede agregar offset)
0812C                           ; ATENCIÓN, se debe especificar en temp0 y temp1 la dirección del mapa de tiles. parte baja y alta respectivamente.
0812C                           ; Se le puede agregar un offset de dirección en el registro X. Dejar en 0 si no se quiere usar
0812C                           .macro COLL_PointInBitmap8 xpos,ypos,xoffset,yoffset
0812C                           	stx temp6 		; Guarda qué jugador está procesando temporalmente
0812C                           	;posición x
0812C                           	lda xpos,x
0812C                           	clc
0812C                           	adc #xoffset
0812C                           	lsr
0812C                           	lsr
0812C                           	lsr
0812C                           	sta temp7 		; Guarda la posicion X en temp7
0812C                           	;posición y
0812C                           	lda ypos,x
0812C                           	clc
0812C                           	adc #yoffset
0812C                           	lsr
0812C                           	lsr
0812C                           	lsr
0812C                           	tay					; posicion tile Y
0812C                           	ldx temp7		; posicion tile X
0812C                           	jsr COLL_TileBitmap8
0812C                           	ldx temp6 	; recupera el jugador que estaba procesando
0812C                           .endm
0812C                           
0812C                           ; Consulta si Un rectángulo está colisionando con un tile del mapa de tiles.
0812C                           ; tlx,tly --- trx,try
0812C                           ;    |           |
0812C                           ;    |           |
0812C                           ;    |           |
0812C                           ;    |           |
0812C                           ; blx,bly --- brx,bry
0812C                           .macro COLL_SquareInTile8 xpos,ypos,coll_addr,tlx,tly,trx,try,blx,bly,brx,bry
0812C                           	; temp3 = coll_flags
0812C                           	
0812C                           	MemCopy #0,temp3		;resetea las colisiones en las 4 esquinas
0812C                           	MemCopy2 #<coll_addr,#>coll_addr,temp0,temp1
0812C                           	COLL_PointInBitmap8 xpos,ypos,tlx,tly
0812C                           	rol temp3
0812C                           	COLL_PointInBitmap8 xpos,ypos,trx,try
0812C                           	rol temp3
0812C                           	COLL_PointInBitmap8 xpos,ypos,blx,bly
0812C                           	rol temp3
0812C                           	COLL_PointInBitmap8 xpos,ypos,brx,bry
0812C                           	rol temp3
0812C                           	; Develve en A los resultados de las colisiones en las 4 esquinas. 
0812C                           	lda temp3
0812C                           .endm
0812C                           
0812C                           ;; SUB-RUTINAS
0812C                           .base ASM_PROGRAM
0812C                           ;	Colisión simple X/Y.	
0812C                           ;	Ejemplo con el eje X: (x1+w1 > x2) && (x2+w2 > x1)
0812C                           ;	Observar que se puede usar la misma función para el eje Y.
0812C                           ;	por lo tanto, para obtener la colisión de un rectángulo/cuadrado,
0812C                           ;	basta con llamar la misma sub-rutina una vez para el eje X, y otra para el eje Y.
0812C                           ;	Parámetros:
0812C                           ;		temp0: Posición X/Y del objeto 1.
0812C                           ;		temp1: Ancho/Alto del objeto 1.
0812C                           ;		temp2: Posición X/Y del objeto 2.
0812C                           ;		temp3: Ancho/Alto del objeto 2.
0812C                           ;	Devuelve:
0812C                           ;		A: 0 si no hubo colisión, 1 si hubo colisión
0812C                           COLL_rectAxis:
0812C                           	x1 = temp0
0812C                           	w1 = temp1
0812C                           	x2 = temp2
0812C                           	w2 = temp3
0812C                           	
0812C A5 00                     	lda x1			; Carga la posición X/Y del obj #1
0812E 18                        	clc				;
0812F 65 01                     	adc w1			; Le suma su ancho/alto
08131 C5 02                     	cmp x2			; Si es más grande que la posición X/Y:
08133 30 0C                     	bmi @no_coll	; Sigue ejecutando. Si no, 
08135 A5 02                     	lda x2			; 
08137 18                        	clc				;
08138 65 03                     	adc w2			; *repite lo mismo de arriba con el objeto #2
0813A C5 00                     	cmp x1			;
0813C 30 03                     	bmi @no_coll	; En caso de haber colisión, devuelve 1 en A
0813E A9 01                     	lda #1			; Devuelve 1 en A
08140 60                        	rts			; Volver de sub-rutina
08141                           @no_coll:
08141 A9 00                     	lda #0			; Devuelve 0 en A.
08143 60                        	rts				; Volver de sub-rutina
08144                           
08144                           ; ; Obtiene en A la posición en un eje de un tile(8,16,32,64)	(especificar addressing mode para TARGET_POS)
08144                           ; COLL_GetTilePosAxis
08144                           	; clc
08144                           	; lda pos_addr
08144                           	; adc #offset
08144                           	; lsr
08144                           	; lsr
08144                           	; lsr
08144                           	
08144                           	; rts				; Volver de sub-rutina
08144                           
08144                           
08144                           ; Consulta si un tile tiene colisión partir de una coordenada de tile X y Y. (Tiles de 8x8 píxeles)
08144                           ; Nota:
08144                           ; 	Ésta sería la fórmula para obtener el byte: Y*4 + X/8
08144                           ;	y ésta fórmula es para obtener la posición del bit: X%8
08144                           ; Parámetros:
08144                           ;	X: Posición X del Tile (0-31)
08144                           ;	Y: Posición Y del Tile (0-29)
08144                           ;	temp0: ubicación del mapa de bits de colisión (byte bajo)
08144                           ;	temp1: ubicación del mapa de bits de colisión (byte alto)
08144                           ; Ocupa:
08144                           ;	Reg A
08144                           ;	temp2: Registro temporal
08144                           ; Devuelve:
08144                           ;	Carry Flag Set: hay colisión
08144                           ;	Carry Flag Clear: no hay colisión
08144                           COLL_TileBitmap8:
08144                           	coll_bitmap = temp0
08144                           	;convierte las coordenadas de tile en ubicación del byte a chequear del mapa de colisiones
08144 98                        	tya			;
08145 0A                        	asl			; A = Y*4
08146 0A                        	asl			;
08147 85 02                     	sta temp2	; temp2 = A; Liberamos Y
08149 8A                        	txa			;
0814A 4A                        	lsr			; A = X/8
0814B 4A                        	lsr			;
0814C 4A                        	lsr			;
0814D 18                        	clc			;
0814E 65 02                     	adc temp2	; A += temp2
08150 A8                        	tay			; Y = A;	Usaremos Y como puntero del byte.
08151                           	;ya tenemos la ubicación del byte, ahora sólo nos queda obtener la posición del bit
08151 8A                        	txa			;
08152 29 07                     	and #7		; X %= 8;	Usaremos X como puntero del bit.
08154 AA                        	tax			;
08155 E8                        	inx			;	Incrementa X para que quede un rango de 1 - 8 (necesario para lo que se viene)
08156                           	;ahora sólo queda buscar el byte determinado por Y comenzando desde la posición en coll_bitmap
08156                           	;y así rotar los bits cuantas veces diga X.
08156 B1 00                     	lda (coll_bitmap),y
08158 2A                        -	rol			; Pasa el Carry <- 7 <- 6 <- 5 <- 4 <- 3 <- 2 <- 1 <- 0 <- Carry
08159 CA                        	dex			; decrementar X no afecta al Carry Flag (menos mal)
0815A D0 FC                     	bne -		; Si X != 0, repite el proceso
0815C 60                        	rts			; Volver de sub-rutina.
0815D                           
0815D                           
0815D                           	
0815D                           ASM_PROGRAM = $
0815D                           
0815D                           ; Incluye dependencias del juego
0815D                           .include "src/game.asm" 						; Lógica del juego en general
0815D                           
0815D                           ;	Jumper (game.asm)
0815D                           ;	por Eliasdbr (eliasdbr@outlook.com)
0815D                           ;	***Escrito para ASM6 v1.6***
0815D                           
0815D                           ; 
0815D                           ; Lógica general del juego
0815D                           ; (Menu, gameplay, etc.)
0815D                           ;
0815D                           
0815D                           ;;	DEFINICIONES
0815D                           GAME_STATE_GAMEPLAY 	.equ 0		; Estado del juego: Gameplay
0815D                           GAME_STATE_PAUSE			.equ 1		; Estado del juego: Pausa
0815D                           GAME_STATE_INTER			.equ 2		; Estado del juego: Intermission
0815D                           GAME_STATE_MENU 			.equ 3		; Estado del juego: Menu
0815D                           
0815D                           ;;	VARIABLES DE PÁGINA CERO
0815D                           .enum ASM_ZEROPAGE
0000F                           game_state			.byte 0 		; Estado del juego.
00010                           														; 	0: Gameplay
00010                           														; 	1: Pausa
00010                           														; 	2: Intermission
00010                           														; 	3: Menu
00010                           two_players 		.byte 0 		; Modo de juego.
00011                           														; 	0: One player
00011                           														; 	1: two players
00011                           ASM_ZEROPAGE = $
00011                           .ende
0815D                           
0815D                           ;;	OTRAS VARIABLES
0815D                           
0815D                           
0815D                           ;;	MACROS
0815D                           
0815D                           
0815D                           ;;	SUB-RUTINAS
0815D                           .base ASM_PROGRAM
0815D                           ; Carga el menú
0815D                           GAME_LoadMenu:
0815D                           	; Deshabilita las interrupciones
0815D 78                        	sei
0815E                           	; Desactiva los gráficos
0815E                           	PPU_Disable 0 						; Es un macro.
0815E A9 00                     	lda #0
08160 8D 00 20                      sta PPUCTRL  ; disable NMI
08163 8D 01 20                      sta PPUMASK  ; disable rendering
08166                           	; Cambia el estado del juego a MENU
08166                           	MemCopy #3,game_state
08166 A9 03                     	lda #3
08168 85 0F                     	sta game_state
0816A                           	; Carga el background del menú
0816A A2 00                     	ldx #<BG_MenuScreen 			; Byte bajo
0816C A0 8A                     	ldy #>BG_MenuScreen 			; Byte alto
0816E A9 00                     	lda #0										; Nametable 0
08170 20 2E 80                  	jsr PPU_loadScreen				; Carga la pantalla
08173                           	; Activar Vblank NMI, Sprites: $0000, Fondo: $1000
08173                           	ctrl_flags = PPUCTRL_NMI_ENABLE | PPUCTRL_BG_PATTERN
08173                           	; Muestra los sprites y el fondo
08173                           	mask_flags = PPUMASK_SHOW_SPR | PPUMASK_SHOW_BG
08173                           	; Reactiva los gráficos
08173                           	PPU_Enable ctrl_flags,mask_flags		;es un macro.
08173 A9 90                     	lda #ctrl_flags
08175 8D 00 20                  	sta PPUCTRL
08178 A9 18                     	lda #mask_flags
0817A 8D 01 20                  	sta PPUMASK
0817D                           	; Vuelve a aceptar interrupciones
0817D 58                        	cli
0817E                           	; Termina la sub-rutina
0817E 60                        	rts
0817F                           
0817F                           ; Carga un nivel
0817F                           GAME_LoadLevel:
0817F                           	; Deshabilita las interrupciones
0817F 78                        	sei
08180                           	; Desactiva los gráficos
08180                           	PPU_Disable 0 						; Es un macro.
08180 A9 00                     	lda #0
08182 8D 00 20                      sta PPUCTRL  ; disable NMI
08185 8D 01 20                      sta PPUMASK  ; disable rendering
08188                           	; Cambia el estado del juego a GAMEPLAY
08188                           	MemCopy #0,game_state
08188 A9 00                     	lda #0
0818A 85 0F                     	sta game_state
0818C                           	; Carga la colisión (temporal)
0818C                           	MemBulkCopy coll,COLL_level_data,120	; MemBulkCopy from,to,amount
0818C A2 77                     	ldx #120-1
0818E                           	-
0818E BD 00 8F                  		lda coll,x
08191 9D 00 03                  		sta COLL_level_data,x
08194 CA                        		dex
08195 D0 F7                     	bne -
08197                           	; Carga el background del menú
08197 A2 00                     	ldx #<bg 			; Byte bajo
08199 A0 86                     	ldy #>bg 			; Byte alto
0819B A9 00                     	lda #0										; Nametable 0
0819D 20 2E 80                  	jsr PPU_loadScreen				; Carga la pantalla
081A0                           	; Activar Vblank NMI, Sprites: $0000, Fondo: $1000
081A0                           	ctrl_flags = PPUCTRL_NMI_ENABLE | PPUCTRL_BG_PATTERN
081A0                           	; Muestra los sprites y el fondo
081A0                           	mask_flags = PPUMASK_SHOW_SPR | PPUMASK_SHOW_BG
081A0                           	; Reactiva los gráficos
081A0                           	PPU_Enable ctrl_flags,mask_flags		;es un macro.
081A0 A9 90                     	lda #ctrl_flags
081A2 8D 00 20                  	sta PPUCTRL
081A5 A9 18                     	lda #mask_flags
081A7 8D 01 20                  	sta PPUMASK
081AA                           	; Vuelve a aceptar interrupciones
081AA 58                        	cli
081AB                           	; Termina la sub-rutina
081AB 60                        	rts
081AC                           
081AC                           ASM_PROGRAM = $
081AC                           
081AC                           .include "src/player.asm" 					; Lógica del jugador
081AC                           ;
081AC                           ; Jumper (player.asm)
081AC                           ; por Eliasdbr (eliasdbr@outlook.com)
081AC                           ; ***Escrito para ASM6 v1.6***
081AC                           ;  
081AC                           ; Player logic
081AC                           
081AC                           ; CONSTANTES
081AC                           PLAYER_SPEED		.equ 2	;velocidad de movimiento (en píxeles/frame)
081AC                           PLAYER_ACCEL		.equ 32 ;aceleración (en sub-píxeles/frame) (es decir: 0.25)
081AC                           PLAYER_TVEL 		.equ 4	;velocidad máxima de caída (en píxeles/frame)
081AC                           PLAYER_JUMPSPD	.equ -3 ;velocidad de salto (en píxeles)
081AC                           PLAYER_WJUMPSPD .equ 3	;velocidad de walljump (en píxeles)
081AC                           PLAYER_WJUMPCD	.equ 10 ;cooldown de walljump (en frames)
081AC                           PLAYER_GRAVITY	.equ 32 ;aceleración de gravedad (en sub-píxeles/frame) (es decir: 0.125)
081AC                           PLAYER_MAXJUMPS .equ 1	;saltos máximos (en el aire)
081AC                           PLAYER_1_SPR = OAM_PAGE + 1*4 ; Sprite 1
081AC                           PLAYER_2_SPR = OAM_PAGE + 2*4 ; Sprite 2
081AC                           
081AC                           ; Variables de uso intensivo	(desde $0000 a $00FF)
081AC                           .enum ASM_ZEROPAGE
00011                           
00011                           ; para llevar la cuenta de cuántos bytes ocupan
00011                           ; los datos de un jugador, creamos una constante.
00011                           
00011                           ply_data_start = $				; '$' representa la dirección actual 
00011                           													; en la que se está ensamblando
00011                           
00011                           player_jumps	.byte 0 		; 0x00 -.
00012                           player_x			.byte 0 		; 0x01  |
00013                           player_xsub 	.byte 0 		; 0x02  |
00014                           player_y			.byte 0 		; 0x03  |
00015                           player_ysub 	.byte 0 		; 0x04   > Player 1 position and movement
00016                           player_xv 		.byte 0 		; 0x05  |
00017                           player_xvsub	.byte 0 		; 0x06  |
00018                           player_yv 		.byte 0 		; 0x07  |
00019                           player_yvsub	.byte 0 		; 0x08  |
0001A                           player_ground .byte 0 		; 0x09  |
0001B                           player_wall 	.byte 0 		; 0x0A  | 
0001C                           player_wjcd 	.byte 0 		; 0x0B -' ; Wall-jump cooldown
0001D                           
0001D                           PLY_DATA_OFFSET = $ - ply_data_start
0001D                           
0001D                           player2_jumps .byte 0 		
0001E                           player2_x 		.byte 0 		
0001F                           player2_xsub  .byte 0 		
00020                           player2_y 		.byte 0 		
00021                           player2_ysub	.byte 0 		
00022                           player2_xv		.byte 0 		
00023                           player2_xvsub .byte 0 		
00024                           player2_yv		.byte 0 		
00025                           player2_yvsub .byte 0 		
00026                           player2_ground .byte 0		
00027                           player2_wall	.byte 0 		
00028                           player2_wjcd 	.byte 0 		; Wall Jump Cooldown
00029                           
00029                           ; (20 bytes)
00029                           
00029                           ASM_ZEROPAGE = $
00029                           .ende
081AC                           ; Variables normales			(desde $0300 a $0800)
081AC                           ; Nada aún
081AC                           
081AC                           ; --- MACROS ---
081AC                           ; Player Physics
081AC                           .macro PLY_PhysicsUpdate player_data_offset
081AC                           	; Mueve al jugador horizontalmente dependiendo del input
081AC                           	; Si acaba de hacer un Wall Jump, no acepta input por unos frames
081AC                           	ldx #player_data_offset 	; Jugador 1
081AC                           	lda player_wjcd,x 				;
081AC                           	bne + 										;
081AC                           		jsr PLY_JoyAccelerateAxis
081AC                           	+
081AC                           	ldx #0	; Jugador 1
081AC                           	MOVE_ApplyVelocityAxisSub player_x,player_xsub,player_xv,player_xvsub
081AC                           	
081AC                           	;Que no se pase del extremo izquierdo
081AC                           	ldx #player_data_offset 	; Jugador 1
081AC                           	lda player_x,x
081AC                           	cmp #5
081AC                           	bmi + 				; si player_x está entre 5 y 7:
081AC                           	cmp #7
081AC                           	bpl +
081AC                           		lda #8			; pone al player en la posición 8 en X
081AC                           		sta player_x,x
081AC                           	+
081AC                           
081AC                           	;Chequea colisión con mapa de tiles. Eje X
081AC                           	ldx #player_data_offset 		; Jugador 1
081AC                           	lda #0						; Resetea las flags de si está tocando las paredes
081AC                           	sta player_wall,x 	;
081AC                           	jsr PLY_CheckWallsX
081AC                           
081AC                           	;Maneja la gravedad y el salto del jugador
081AC                           	ldx #player_data_offset 		; Jugador 1
081AC                           	jsr PLY_JumpFall	;
081AC                           	
081AC                           	; Chequea colisión con mapa de tiles. Eje Y
081AC                           	ldx #player_data_offset						; Jugador 1
081AC                           	jsr PLY_CheckWallsY
081AC                           .endm
081AC                           
081AC                           ; --- SUB-RUTINAS ---
081AC                           .base ASM_PROGRAM
081AC                           
081AC                           ; Player Spawn
081AC                           ; Inicializa al jugador
081AC                           ; Parámetros:
081AC                           ; 	X: 0: Jugador 1
081AC                           ; 		 9: Jugador 2
081AC                           PLY_Spawn:
081AC                           	; Resetea las velocidades
081AC A9 00                     	lda #0
081AE 95 18                     	sta player_yv,x
081B0 95 15                     	sta player_ysub,x
081B2 95 19                     	sta player_yvsub,x
081B4 95 16                     	sta player_xv,x
081B6 95 13                     	sta player_xsub,x
081B8 95 17                     	sta player_xvsub,x
081BA                           	; Resetea el cooldown del walljump
081BA 95 1C                     	sta player_wjcd,x
081BC                           	; Punto de entrada del nivel (proximamente será reemplazado por la info del nivel)
081BC A9 40                     	lda #$40
081BE 95 12                     	sta player_x,x
081C0 A9 80                     	lda #$80
081C2 95 14                     	sta player_y,x
081C4                           	; Resetea los saltos
081C4 A9 01                     	lda #1
081C6 95 11                     	sta player_jumps,x
081C8 60                        	rts 	; Volver de Sub-Rutina
081C9                           
081C9                           ; Aceleración horizontal dependiendo del input
081C9                           ; Parámetros:
081C9                           ; 	X: Offset de datos del jugador (0 o PLY_DATA_OFFSET)
081C9                           PLY_JoyAccelerateAxis:
081C9                           	; Mira qué jugador está por procesar en el registro X
081C9 8A                        	txa
081CA D0 0C                     	bne + 							; Si es el jugador 2, saltea al otro joypad
081CC                           		IO_CheckButton 1,JP_LEFT,0
081CC A5 0B                     	lda joypad1 + (1 - 1)*2
081CE 29 02                     	and #JP_LEFT
081D0 F0 00                     	beq @end
081D2                           	IF 0
081D2                           		eor joypad1_prev + (1 - 1)*2
081D2                           		and #JP_LEFT
081D2                           	ENDIF
081D2                           	@end:
081D2 C9 00                     	cmp #0
081D4                           	; Regresa el estado de la flag "Zero"
081D4                           	; También deja el estado del botón en A.
081D4                           	; (A == 0: Falso -- A != 0: Verdadero)
081D4 A8                        		tay 							; Almacena temporalmente el resultado.
081D5 4C E1 81                  		jmp ++						; Saltea el joypad 2
081D8                           	+
081D8                           		IO_CheckButton 2,JP_LEFT,0
081D8 A5 0D                     	lda joypad1 + (2 - 1)*2
081DA 29 02                     	and #JP_LEFT
081DC F0 00                     	beq @end
081DE                           	IF 0
081DE                           		eor joypad1_prev + (2 - 1)*2
081DE                           		and #JP_LEFT
081DE                           	ENDIF
081DE                           	@end:
081DE C9 00                     	cmp #0
081E0                           	; Regresa el estado de la flag "Zero"
081E0                           	; También deja el estado del botón en A.
081E0                           	; (A == 0: Falso -- A != 0: Verdadero)
081E0 A8                        		tay 							; Almacena temporalmente el resultado.
081E1                           	++
081E1 98                        	tya 								; Recupera el estado del botón presionado (Libera Y)
081E2 F0 32                     	beq ++							; Si el botón < está siendo presionado:
081E4                           		; Acelera hacia la izquierda.
081E4                           		; recibe por el reg X la dirección del jugaor
081E4                           		MOVE_ApplyVelocityAxisSub player_xv,player_xvsub,#-1,#-32
081E4 18                        	clc 						;
081E5 B5 17                     	lda player_xvsub,x 	;
081E7 69 E0                     	adc #-32 		;
081E9 95 17                     	sta player_xvsub,x 	;
081EB B5 16                     	lda player_xv,x 			;
081ED 69 FF                     	adc #-1 				;
081EF 95 16                     	sta player_xv,x 			;
081F1                           		; Si estaba yendo a la derecha, frena más rápido.
081F1 B5 16                     		lda player_xv,x
081F3 30 0D                     		bmi +
081F5                           			MOVE_ApplyVelocityAxisSub player_xv,player_xvsub,#-1,#-32*2
081F5 18                        	clc 						;
081F6 B5 17                     	lda player_xvsub,x 	;
081F8 69 C0                     	adc #-32*2 		;
081FA 95 17                     	sta player_xvsub,x 	;
081FC B5 16                     	lda player_xv,x 			;
081FE 69 FF                     	adc #-1 				;
08200 95 16                     	sta player_xv,x 			;
08202                           		+
08202 B5 16                     		lda player_xv,x 		; Chequea si superó la velocidad máxima:
08204 C9 FE                     		cmp #-2	;
08206 10 0D                     		bpl @maxv						; 
08208                           			; Desacelera hasta igualar la velocidad máxima
08208                           			MOVE_ApplyVelocityAxisSub player_xv,player_xvsub,#0,#32*2
08208 18                        	clc 						;
08209 B5 17                     	lda player_xvsub,x 	;
0820B 69 40                     	adc #32*2 		;
0820D 95 17                     	sta player_xvsub,x 	;
0820F B5 16                     	lda player_xv,x 			;
08211 69 00                     	adc #0 				;
08213 95 16                     	sta player_xv,x 			;
08215                           			;lda #-PLAYER_SPEED 
08215                           			;sta player_xv,x 	; Hace clamp a la velocidad máxima
08215                           			;lda #0						;
08215                           			;sta player_xvsub,x
08215                           			;sta player_xsub,x
08215                           		@maxv: 							;
08215 60                        		rts 			; Fin de aceleración
08216                           	++
08216 8A                        	txa 								; Mira de nuevo qué jugador estamos procesando
08217 D0 0C                     	bne + 							; Si es el jugador 2, saltea al otro joypad
08219                           		IO_CheckButton 1,JP_RIGHT,0
08219 A5 0B                     	lda joypad1 + (1 - 1)*2
0821B 29 01                     	and #JP_RIGHT
0821D F0 00                     	beq @end
0821F                           	IF 0
0821F                           		eor joypad1_prev + (1 - 1)*2
0821F                           		and #JP_RIGHT
0821F                           	ENDIF
0821F                           	@end:
0821F C9 00                     	cmp #0
08221                           	; Regresa el estado de la flag "Zero"
08221                           	; También deja el estado del botón en A.
08221                           	; (A == 0: Falso -- A != 0: Verdadero)
08221 A8                        		tay 							; Almacena temporalmente el resultado.
08222 4C 2E 82                  		jmp ++						; Saltea el joypad 2
08225                           	+
08225                           		IO_CheckButton 2,JP_RIGHT,0
08225 A5 0D                     	lda joypad1 + (2 - 1)*2
08227 29 01                     	and #JP_RIGHT
08229 F0 00                     	beq @end
0822B                           	IF 0
0822B                           		eor joypad1_prev + (2 - 1)*2
0822B                           		and #JP_RIGHT
0822B                           	ENDIF
0822B                           	@end:
0822B C9 00                     	cmp #0
0822D                           	; Regresa el estado de la flag "Zero"
0822D                           	; También deja el estado del botón en A.
0822D                           	; (A == 0: Falso -- A != 0: Verdadero)
0822D A8                        		tay 							; Almacena temporalmente el resultado.
0822E                           	++
0822E 98                        	tya 								; Recupera el estado del botón presionado (Libera Y)
0822F F0 32                     	beq ++							; Si el botón > está siendo presionado:
08231                           		; Acelera hacia la derecha.
08231                           		MOVE_ApplyVelocityAxisSub player_xv,player_xvsub,#0,#32
08231 18                        	clc 						;
08232 B5 17                     	lda player_xvsub,x 	;
08234 69 20                     	adc #32 		;
08236 95 17                     	sta player_xvsub,x 	;
08238 B5 16                     	lda player_xv,x 			;
0823A 69 00                     	adc #0 				;
0823C 95 16                     	sta player_xv,x 			;
0823E                           		; Si estaba yendo a la izquierda, frena más rápido.
0823E B5 16                     		lda player_xv,x
08240 10 0D                     		bpl +
08242                           			MOVE_ApplyVelocityAxisSub player_xv,player_xvsub,#0,#32*2
08242 18                        	clc 						;
08243 B5 17                     	lda player_xvsub,x 	;
08245 69 40                     	adc #32*2 		;
08247 95 17                     	sta player_xvsub,x 	;
08249 B5 16                     	lda player_xv,x 			;
0824B 69 00                     	adc #0 				;
0824D 95 16                     	sta player_xv,x 			;
0824F                           		+
0824F B5 16                     		lda player_xv,x 		; Chequea si superó la velocidad máxima:
08251 C9 02                     		cmp #2 	;
08253 30 0D                     		bmi @minv						; De ser así:
08255                           			; Desacelera hasta igualar la velocidad máxima
08255                           			MOVE_ApplyVelocityAxisSub player_xv,player_xvsub,#-1,#-32*2
08255 18                        	clc 						;
08256 B5 17                     	lda player_xvsub,x 	;
08258 69 C0                     	adc #-32*2 		;
0825A 95 17                     	sta player_xvsub,x 	;
0825C B5 16                     	lda player_xv,x 			;
0825E 69 FF                     	adc #-1 				;
08260 95 16                     	sta player_xv,x 			;
08262                           			;lda #PLAYER_SPEED ;
08262                           			;sta player_xv,x		; Hace clamp a la velocidad máxima
08262                           			;lda #0						;
08262                           			;sta player_xvsub,x
08262                           			;sta player_xsub,x
08262                           		@minv: 							;
08262 60                        		rts 								; Fin de la aceleración.
08263                           	++ 
08263                           		; - Desaceleración -
08263 B5 16                     	lda player_xv,x			; Si ningún botón está siendo presionado:
08265 D0 04                     	bne + 							; Y si la velocidad actual del jugador es 0:
08267 B5 17                     		lda player_xvsub,x; Chequea si la velocidad sub-pixel es 0.
08269 F0 1F                     		beq end_input 		; Si es cero, termina la desaceleración.
0826B                           	+ 
0826B B5 16                     	lda player_xv,x 		; Chequea si la velocidad es negativa
0826D 30 0E                     	bmi + 							; 
0826F                           	; Si es positiva, desacelera hacia la izquierda.
0826F                           		MOVE_ApplyVelocityAxisSub player_xv,player_xvsub,#-1,#-32
0826F 18                        	clc 						;
08270 B5 17                     	lda player_xvsub,x 	;
08272 69 E0                     	adc #-32 		;
08274 95 17                     	sta player_xvsub,x 	;
08276 B5 16                     	lda player_xv,x 			;
08278 69 FF                     	adc #-1 				;
0827A 95 16                     	sta player_xv,x 			;
0827C 60                        		rts 							; Termina
0827D                           	+ 
0827D                           	; Si es negativa, desacelera hacia la derecha.
0827D                           	MOVE_ApplyVelocityAxisSub player_xv,player_xvsub,#0,#32
0827D 18                        	clc 						;
0827E B5 17                     	lda player_xvsub,x 	;
08280 69 20                     	adc #32 		;
08282 95 17                     	sta player_xvsub,x 	;
08284 B5 16                     	lda player_xv,x 			;
08286 69 00                     	adc #0 				;
08288 95 16                     	sta player_xv,x 			;
0828A                           end_input: 
0828A 60                        	rts
0828B                           	; FIN DE SUB-RUTINA
0828B                           
0828B                           ; Colisión del jugador en el eje X
0828B                           ; Recibe en el reg X qué jugador procesa
0828B                           PLY_CheckWallsX:
0828B                           	; (sub-rutina)
0828B                           	; Chequea la colisión en sus anchas
0828B                           	; -1,0 --- 8,0
0828B                           	;   |       |
0828B                           	;   |       |
0828B                           	; -1,7 --- 8,7
0828B                           	; 
0828B                           	COLL_SquareInTile8 player_x,player_y,COLL_level_data,-1,0,8,0,-1,7,8,7
0828B                           	; temp3 = coll_flags
0828B                           	
0828B                           	MemCopy #0,temp3		;resetea las colisiones en las 4 esquinas
0828B A9 00                     	lda #0
0828D 85 03                     	sta temp3
0828F                           	MemCopy2 #<COLL_level_data,#>COLL_level_data,temp0,temp1
0828F A2 00                     	ldx #<COLL_level_data
08291 A0 03                     	ldy #>COLL_level_data
08293 86 00                     	stx temp0
08295 84 01                     	sty temp1
08297                           	COLL_PointInBitmap8 player_x,player_y,-1,0
08297 86 06                     	stx temp6 		; Guarda qué jugador está procesando temporalmente
08299                           	;posición x
08299 B5 12                     	lda player_x,x
0829B 18                        	clc
0829C 69 FF                     	adc #-1
0829E 4A                        	lsr
0829F 4A                        	lsr
082A0 4A                        	lsr
082A1 85 07                     	sta temp7 		; Guarda la posicion X en temp7
082A3                           	;posición y
082A3 B5 14                     	lda player_y,x
082A5 18                        	clc
082A6 69 00                     	adc #0
082A8 4A                        	lsr
082A9 4A                        	lsr
082AA 4A                        	lsr
082AB A8                        	tay					; posicion tile Y
082AC A6 07                     	ldx temp7		; posicion tile X
082AE 20 44 81                  	jsr COLL_TileBitmap8
082B1 A6 06                     	ldx temp6 	; recupera el jugador que estaba procesando
082B3 26 03                     	rol temp3
082B5                           	COLL_PointInBitmap8 player_x,player_y,8,0
082B5 86 06                     	stx temp6 		; Guarda qué jugador está procesando temporalmente
082B7                           	;posición x
082B7 B5 12                     	lda player_x,x
082B9 18                        	clc
082BA 69 08                     	adc #8
082BC 4A                        	lsr
082BD 4A                        	lsr
082BE 4A                        	lsr
082BF 85 07                     	sta temp7 		; Guarda la posicion X en temp7
082C1                           	;posición y
082C1 B5 14                     	lda player_y,x
082C3 18                        	clc
082C4 69 00                     	adc #0
082C6 4A                        	lsr
082C7 4A                        	lsr
082C8 4A                        	lsr
082C9 A8                        	tay					; posicion tile Y
082CA A6 07                     	ldx temp7		; posicion tile X
082CC 20 44 81                  	jsr COLL_TileBitmap8
082CF A6 06                     	ldx temp6 	; recupera el jugador que estaba procesando
082D1 26 03                     	rol temp3
082D3                           	COLL_PointInBitmap8 player_x,player_y,-1,7
082D3 86 06                     	stx temp6 		; Guarda qué jugador está procesando temporalmente
082D5                           	;posición x
082D5 B5 12                     	lda player_x,x
082D7 18                        	clc
082D8 69 FF                     	adc #-1
082DA 4A                        	lsr
082DB 4A                        	lsr
082DC 4A                        	lsr
082DD 85 07                     	sta temp7 		; Guarda la posicion X en temp7
082DF                           	;posición y
082DF B5 14                     	lda player_y,x
082E1 18                        	clc
082E2 69 07                     	adc #7
082E4 4A                        	lsr
082E5 4A                        	lsr
082E6 4A                        	lsr
082E7 A8                        	tay					; posicion tile Y
082E8 A6 07                     	ldx temp7		; posicion tile X
082EA 20 44 81                  	jsr COLL_TileBitmap8
082ED A6 06                     	ldx temp6 	; recupera el jugador que estaba procesando
082EF 26 03                     	rol temp3
082F1                           	COLL_PointInBitmap8 player_x,player_y,8,7
082F1 86 06                     	stx temp6 		; Guarda qué jugador está procesando temporalmente
082F3                           	;posición x
082F3 B5 12                     	lda player_x,x
082F5 18                        	clc
082F6 69 08                     	adc #8
082F8 4A                        	lsr
082F9 4A                        	lsr
082FA 4A                        	lsr
082FB 85 07                     	sta temp7 		; Guarda la posicion X en temp7
082FD                           	;posición y
082FD B5 14                     	lda player_y,x
082FF 18                        	clc
08300 69 07                     	adc #7
08302 4A                        	lsr
08303 4A                        	lsr
08304 4A                        	lsr
08305 A8                        	tay					; posicion tile Y
08306 A6 07                     	ldx temp7		; posicion tile X
08308 20 44 81                  	jsr COLL_TileBitmap8
0830B A6 06                     	ldx temp6 	; recupera el jugador que estaba procesando
0830D 26 03                     	rol temp3
0830F                           	; Develve en A los resultados de las colisiones en las 4 esquinas. 
0830F A5 03                     	lda temp3
08311                           	; ldx #0 ; TEST Jugador 1
08311 95 1B                     	sta player_wall,x ; Guarda la info de colisión
08313 A8                        	tay 							; Copia las colisiones al reg Y
08314 29 0A                     	and #%00001010		; Chequea las dos esquinas de la izquierda
08316 F0 15                     	beq + 						; si no hay colisión, chequea el siguiente lado
08318 B5 12                     		lda player_x,x	; Pero si hay colision:
0831A 18                        		clc 						;
0831B 69 07                     		adc #7					; Acomoda al jugador en el tile de la derecha.
0831D 29 F8                     		and #%11111000	;
0831F 95 12                     		sta player_x,x	;
08321 B5 16                     		lda player_xv,x ; Si se estaba moviendo...
08323 F0 08                     		beq + 					;
08325 A9 00                     			lda #0					; resetea la velocidad horizontal.
08327 95 16                     			sta player_xv,x 
08329 95 17                     			sta player_xvsub,x
0832B 95 13                     			sta player_xsub,x
0832D                           	+ 
0832D 98                        	tya 							; Recupera las colisiones
0832E 29 05                     	and #%00000101		; Chequea las dos esquinas del lado de la derecha
08330 F0 12                     	beq + 						; si no hay colisión, termina, no pasa más nada
08332 B5 12                     		lda player_x,x	; Pero si hay colision:
08334 29 F8                     		and #%11111000	; Acomoda el jugador en el tile de la izquierda
08336 95 12                     		sta player_x,x	;
08338 B5 16                     		lda player_xv,x ; Si se estaba moviendo...
0833A F0 08                     		beq + 					;
0833C A9 00                     			lda #0					; resetea la velocidad horizontal.
0833E 95 16                     			sta player_xv,x 
08340 95 17                     			sta player_xvsub,x
08342 95 13                     			sta player_xsub,x
08344                           	+
08344 60                        	rts
08345                           
08345                           ; Chequea colisión con las paredes en el eje Y
08345                           PLY_CheckWallsY:
08345                           	; (sub-rutina)
08345                           	; Chequea la colisión en sus altas
08345                           	; 0,0 --- 7,0
08345                           	;  |       |
08345                           	;  |       |
08345                           	; 0,8 --- 7,8
08345                           	; 
08345                           	COLL_SquareInTile8 player_x,player_y,COLL_level_data,0,0,7,0,0,8,7,8
08345                           	; temp3 = coll_flags
08345                           	
08345                           	MemCopy #0,temp3		;resetea las colisiones en las 4 esquinas
08345 A9 00                     	lda #0
08347 85 03                     	sta temp3
08349                           	MemCopy2 #<COLL_level_data,#>COLL_level_data,temp0,temp1
08349 A2 00                     	ldx #<COLL_level_data
0834B A0 03                     	ldy #>COLL_level_data
0834D 86 00                     	stx temp0
0834F 84 01                     	sty temp1
08351                           	COLL_PointInBitmap8 player_x,player_y,0,0
08351 86 06                     	stx temp6 		; Guarda qué jugador está procesando temporalmente
08353                           	;posición x
08353 B5 12                     	lda player_x,x
08355 18                        	clc
08356 69 00                     	adc #0
08358 4A                        	lsr
08359 4A                        	lsr
0835A 4A                        	lsr
0835B 85 07                     	sta temp7 		; Guarda la posicion X en temp7
0835D                           	;posición y
0835D B5 14                     	lda player_y,x
0835F 18                        	clc
08360 69 00                     	adc #0
08362 4A                        	lsr
08363 4A                        	lsr
08364 4A                        	lsr
08365 A8                        	tay					; posicion tile Y
08366 A6 07                     	ldx temp7		; posicion tile X
08368 20 44 81                  	jsr COLL_TileBitmap8
0836B A6 06                     	ldx temp6 	; recupera el jugador que estaba procesando
0836D 26 03                     	rol temp3
0836F                           	COLL_PointInBitmap8 player_x,player_y,7,0
0836F 86 06                     	stx temp6 		; Guarda qué jugador está procesando temporalmente
08371                           	;posición x
08371 B5 12                     	lda player_x,x
08373 18                        	clc
08374 69 07                     	adc #7
08376 4A                        	lsr
08377 4A                        	lsr
08378 4A                        	lsr
08379 85 07                     	sta temp7 		; Guarda la posicion X en temp7
0837B                           	;posición y
0837B B5 14                     	lda player_y,x
0837D 18                        	clc
0837E 69 00                     	adc #0
08380 4A                        	lsr
08381 4A                        	lsr
08382 4A                        	lsr
08383 A8                        	tay					; posicion tile Y
08384 A6 07                     	ldx temp7		; posicion tile X
08386 20 44 81                  	jsr COLL_TileBitmap8
08389 A6 06                     	ldx temp6 	; recupera el jugador que estaba procesando
0838B 26 03                     	rol temp3
0838D                           	COLL_PointInBitmap8 player_x,player_y,0,8
0838D 86 06                     	stx temp6 		; Guarda qué jugador está procesando temporalmente
0838F                           	;posición x
0838F B5 12                     	lda player_x,x
08391 18                        	clc
08392 69 00                     	adc #0
08394 4A                        	lsr
08395 4A                        	lsr
08396 4A                        	lsr
08397 85 07                     	sta temp7 		; Guarda la posicion X en temp7
08399                           	;posición y
08399 B5 14                     	lda player_y,x
0839B 18                        	clc
0839C 69 08                     	adc #8
0839E 4A                        	lsr
0839F 4A                        	lsr
083A0 4A                        	lsr
083A1 A8                        	tay					; posicion tile Y
083A2 A6 07                     	ldx temp7		; posicion tile X
083A4 20 44 81                  	jsr COLL_TileBitmap8
083A7 A6 06                     	ldx temp6 	; recupera el jugador que estaba procesando
083A9 26 03                     	rol temp3
083AB                           	COLL_PointInBitmap8 player_x,player_y,7,8
083AB 86 06                     	stx temp6 		; Guarda qué jugador está procesando temporalmente
083AD                           	;posición x
083AD B5 12                     	lda player_x,x
083AF 18                        	clc
083B0 69 07                     	adc #7
083B2 4A                        	lsr
083B3 4A                        	lsr
083B4 4A                        	lsr
083B5 85 07                     	sta temp7 		; Guarda la posicion X en temp7
083B7                           	;posición y
083B7 B5 14                     	lda player_y,x
083B9 18                        	clc
083BA 69 08                     	adc #8
083BC 4A                        	lsr
083BD 4A                        	lsr
083BE 4A                        	lsr
083BF A8                        	tay					; posicion tile Y
083C0 A6 07                     	ldx temp7		; posicion tile X
083C2 20 44 81                  	jsr COLL_TileBitmap8
083C5 A6 06                     	ldx temp6 	; recupera el jugador que estaba procesando
083C7 26 03                     	rol temp3
083C9                           	; Develve en A los resultados de las colisiones en las 4 esquinas. 
083C9 A5 03                     	lda temp3
083CB                           	; ldx #0	; Jugador 1
083CB A8                        	tay 											; Copia las colisiones
083CC 29 0C                     	and #%00001100						; Chequea las dos esquinas de arriba
083CE F0 11                     	beq + 										; si no hay colisión, chequea el siguiente lado
083D0 B5 14                     		lda player_y,x					; Pero si hay colision:
083D2 18                        		clc 										;
083D3 69 07                     		adc #7									; Acomoda al jugador en el tile de abajo.
083D5 29 F8                     		and #%11111000					;
083D7 95 14                     		sta player_y,x					;
083D9 A9 00                     		lda #0									; Si está saltando, lo detiene
083DB 95 18                     		sta player_yv,x 				;
083DD 95 19                     		sta player_yvsub,x			;
083DF 95 15                     		sta player_ysub,x 			;
083E1                           	+
083E1 98                        	tya 											; Recupera las colisiones
083E2 29 03                     	and #%00000011						; Chequea las dos esquinas de abajo
083E4 F0 19                     	beq + 										; si no hay colisión, está en el aire
083E6                           		; A veces no entra acá siendo que si está tocando el suelo...
083E6 B5 14                     		lda player_y,x					; Pero si hay colision:
083E8 29 F8                     		and #%11111000					; Acomoda el jugador en el tile de arriba
083EA 95 14                     		sta player_y,x					;
083EC A9 00                     		lda #0									; Si está cayendo, lo detiene.
083EE 95 18                     		sta player_yv,x 				; Ha tocado el suelo
083F0 95 19                     		sta player_yvsub,x			;
083F2 95 15                     		sta player_ysub,x 			;
083F4 A9 01                     		lda #1		; Resetea los saltos disponibles.
083F6 95 11                     		sta player_jumps,x			; 
083F8 A9 01                     		lda #1									; Indica que está tocando el suelo.
083FA 95 1A                     		sta player_ground,x 		;
083FC 4C 03 84                  		jmp ++									; termina
083FF                           	+ 												; Si no toca el suelo, está en el aire
083FF A9 00                     		lda #0									;
08401 95 1A                     		sta player_ground,x 		;
08403                           	++
08403 60                        	rts
08404                           
08404                           ; Salto y gravedad del jugador
08404                           PLY_JumpFall:
08404                           	; Wall Jump
08404 B5 1C                     	lda player_wjcd,x 	; Decrementa el timer
08406 F0 02                     	beq + 							; del cooldown del walljump
08408 D6 1C                     		dec player_wjcd,x ; hasta llegar a 0.
0840A                           	+
0840A                           	; Salto de Ogmo
0840A                           	IO_CheckButton 1,JP_A,1	; Si acaba de presionar el botón A:
0840A A5 0B                     	lda joypad1 + (1 - 1)*2
0840C 29 80                     	and #JP_A
0840E F0 04                     	beq @end
08410                           	IF 1
08410 45 0C                     		eor joypad1_prev + (1 - 1)*2
08412 29 80                     		and #JP_A
08414                           	ENDIF
08414                           	@end:
08414 C9 00                     	cmp #0
08416                           	; Regresa el estado de la flag "Zero"
08416                           	; También deja el estado del botón en A.
08416                           	; (A == 0: Falso -- A != 0: Verdadero)
08416 F0 64                     	beq +++ 										;
08418 B5 1A                     	lda player_ground,x 				; Si no está tocando el suelo:
0841A D0 4E                     	bne ++											;
0841C                           		; Chequea si está presionando <
0841C                           		IO_CheckButton 1,JP_LEFT,0
0841C A5 0B                     	lda joypad1 + (1 - 1)*2
0841E 29 02                     	and #JP_LEFT
08420 F0 00                     	beq @end
08422                           	IF 0
08422                           		eor joypad1_prev + (1 - 1)*2
08422                           		and #JP_LEFT
08422                           	ENDIF
08422                           	@end:
08422 C9 00                     	cmp #0
08424                           	; Regresa el estado de la flag "Zero"
08424                           	; También deja el estado del botón en A.
08424                           	; (A == 0: Falso -- A != 0: Verdadero)
08424 F0 1D                     		beq +
08426 B5 1B                     		lda player_wall,x 					; y si está tocando la pared izquierda
08428 29 0A                     		and #%00001010							;
0842A F0 17                     		beq + 											;
0842C A9 03                     			lda #3			; Hace un walljump hacia la derecha
0842E 95 16                     			sta player_xv,x 					; 
08430 A9 FD                     			lda #-3 			; Salta un poco hacia arriba también
08432 95 18                     			sta player_yv,x 					;
08434 A9 80                     			lda #-128									; -2.5
08436 95 19                     			sta player_yvsub,x				;
08438 A9 00                     			lda #0										; (redondea las velocidades)
0843A 95 17                     			sta player_xvsub,x				;
0843C A9 0A                     			lda #10 			; resetea el contador de cooldown
0843E 95 1C                     			sta player_wjcd,x 				; del walljump
08440 4C 7C 84                  			jmp +++										; Termina
08443                           		+
08443                           		; Chequea si está presionando >
08443                           		IO_CheckButton 1,JP_RIGHT,0
08443 A5 0B                     	lda joypad1 + (1 - 1)*2
08445 29 01                     	and #JP_RIGHT
08447 F0 00                     	beq @end
08449                           	IF 0
08449                           		eor joypad1_prev + (1 - 1)*2
08449                           		and #JP_RIGHT
08449                           	ENDIF
08449                           	@end:
08449 C9 00                     	cmp #0
0844B                           	; Regresa el estado de la flag "Zero"
0844B                           	; También deja el estado del botón en A.
0844B                           	; (A == 0: Falso -- A != 0: Verdadero)
0844B F0 1D                     		beq ++
0844D B5 1B                     		lda player_wall,x 					; y si está tocando la pared derecha
0844F 29 05                     		and #%00000101							;
08451 F0 17                     		beq ++											;
08453 A9 FD                     			lda #-3 		; Hace un walljump hacia la izquierda
08455 95 16                     			sta player_xv,x 					; 
08457 A9 FD                     			lda #-3 			; Salta un poco hacia arriba también
08459 95 18                     			sta player_yv,x 					;
0845B A9 80                     			lda #-128									; -2.5
0845D 95 19                     			sta player_yvsub,x				;
0845F A9 00                     			lda #0										; (redondea las velocidades)
08461 95 17                     			sta player_xvsub,x					;
08463 A9 0A                     			lda #10 			; resetea el contador de cooldown
08465 95 1C                     			sta player_wjcd,x 				; del walljump
08467 4C 7C 84                  			jmp +++ 									; Termina
0846A                           	++
0846A B5 11                     	lda player_jumps,x					; Y si quedan saltos disponibles:
0846C F0 0E                     	beq +++ 										;
0846E A9 FD                     		lda #-3				; Salta
08470 95 18                     		sta player_yv,x 					;
08472 A9 00                     		lda #0										; (pone la velocidad vertical a 4.0)
08474 95 19                     		sta player_yvsub,x				;
08476 B5 1A                     		lda player_ground,x 			; Si no está tocando el suelo:
08478 D0 02                     		bne +++ 									;
0847A D6 11                     			dec player_jumps,x			; quita un salto disponible.
0847C                           	+++
0847C                           	;Gravedad
0847C B5 18                     	lda player_yv,x 						; Si la velocidad vertical actual
0847E C9 04                     	cmp #4						; no supera la velocidad terminal:
08480 10 14                     	bpl + 											;
08482 B5 1A                     	lda player_ground,x 				; Si no está tocando el suelo:
08484 D0 10                     	bne + 											;
08486                           		; Agrega gravedad.
08486                           		MOVE_ApplyVelocityAxisSub player_yv,player_yvsub,#0,#32
08486 18                        	clc 						;
08487 B5 19                     	lda player_yvsub,x 	;
08489 69 20                     	adc #32 		;
0848B 95 19                     	sta player_yvsub,x 	;
0848D B5 18                     	lda player_yv,x 			;
0848F 69 00                     	adc #0 				;
08491 95 18                     	sta player_yv,x 			;
08493 4C 9C 84                  		jmp ++											; pasa directamente a aplicar la velocidad
08496                           	+ 
08496 A9 00                     	lda #0											; Si alcanzó la velocidad terminal:
08498 95 19                     	sta player_yvsub,x					; Resetea la velocidad sub-pixel.
0849A 95 15                     	sta player_ysub,x 					; Resetea la posición sub-pixel.
0849C                           	
0849C                           	++
0849C                           	; Mueve al jugador en el eje Y.
0849C                           	MOVE_ApplyVelocityAxisSub player_y,player_ysub,player_yv,player_yvsub
0849C 18                        	clc 						;
0849D B5 15                     	lda player_ysub,x 	;
0849F 65 19                     	adc player_yvsub 		;
084A1 95 15                     	sta player_ysub,x 	;
084A3 B5 14                     	lda player_y,x 			;
084A5 65 18                     	adc player_yv 				;
084A7 95 14                     	sta player_y,x 			;
084A9 60                        	rts
084AA                           
084AA                           
084AA                           ASM_PROGRAM = $
084AA                           
084AA                           
084AA                           ; Constantes del Juego
084AA                           ; ---
084AA                           
084AA                           ; Variables de uso intensivo	(desde $0000 a $00FF)
084AA                           .enum ASM_ZEROPAGE
00029                           ; (xxx bytes usados de librerías)
00029                           ASM_ZEROPAGE = $
00029                           .ende
084AA                           
084AA                           ; Variables normales			(desde $0300 a $0800)
084AA                           ; Nada aún
084AA                           
084AA                           
084AA                           .base ASM_PROGRAM	; Continuamos escribiendo programa
084AA                           
084AA                           	; # - - - - - - - - - - - - - - - - - - - - - - - - - - #
084AA                           	; # - - - Arranque del Juego (luego del RESET)  - - - - #
084AA                           	; # - - - - - - - - - - - - - - - - - - - - - - - - - - #
084AA                           main_setup:
084AA                           	
084AA                           	; --- Inicializa el Juego ---
084AA                           	
084AA                           	; Carga el menú, establece el game_state a MENU
084AA 20 5D 81                  	jsr GAME_LoadMenu
084AD                           	
084AD                           	MemCopy #0,two_players	; Modo Un jugador
084AD A9 00                     	lda #0
084AF 85 10                     	sta two_players
084B1                           	
084B1 A9 00                     	lda #0				; Resetea el scroll
084B3 85 08                     	sta scroll_x
084B5 85 09                     	sta scroll_y
084B7                           	
084B7                           	
084B7                           	
084B7                           	; # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
084B7                           	; # - - - Loop principal del Juego	(cada frame, después del VBLANK)  - - - #
084B7                           	; # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
084B7                           main_loop:
084B7                           	;obtiene los joypads 
084B7                           	IO_JoyUpdate						; (Macro)
084B7                           	; Actualiza los botones previos
084B7 A6 0B                     	ldx joypad1
084B9 A4 0D                     	ldy joypad2
084BB 86 0C                     	stx joypad1_prev
084BD 84 0E                     	sty joypad2_prev
084BF                           	; Actualiza los botones actuales
084BF A9 01                     	lda #$01
084C1 85 0B                     	sta joypad1 	;le ponemos 1 a joypad1 para indicar cuándo llega a mirar los 8 botones.
084C3 85 0D                     	sta joypad2 	; repetir con el joystick 2
084C5 8D 16 40                  	sta JOYPAD1 	;decirle a los controles(joysticks) #1 y #2 que miren qué botones se están apretando.
084C8 8D 17 40                  	sta JOYPAD2 	; repetir con el joystick 2
084CB A9 00                     	lda #$00
084CD 8D 16 40                  	sta JOYPAD1 	;decirle al control(joystick) #1 que guarde lo botones que miró.
084D0 8D 17 40                  	sta JOYPAD2 	; repetir con el joystick 2
084D3                           	; Ahora le pediremos al joystick si los botones estaban presionados o no, uno por uno.
084D3 18                        	clc
084D4                           	-
084D4 AD 16 40                  	lda JOYPAD1 	;preguntamos el estado del botón actual
084D7 4A                        	lsr 					;mete el estado del botón actual en el carry flag.
084D8 26 0B                     	rol joypad1 	;pone el bit7 en el Carry y lo que estaba en el Carry lo manda al bit0
084DA 90 F8                     	bcc - 				;si se obtienen los 8 botones, el carry estará en 1, si no, volvemos a pedir un boton.
084DC 18                        	clc 					;
084DD                           	-
084DD AD 17 40                  	lda JOYPAD2 	; repetir con el joystick 2
084E0 4A                        	lsr 					;
084E1 26 0D                     	rol joypad2 	;
084E3 90 F8                     	bcc - 				;
084E5                           	
084E5                           	; 
084E5                           	; Chequea el estado del juego (game_state)
084E5                           	; 
084E5                           	
084E5 A5 0F                     	lda game_state
084E7 D0 03                     	bne +
084E9 4C FD 84                  		jmp GameplayLogic
084EC                           	+
084EC C9 01                     	cmp #1
084EE D0 03                     	bne +
084F0 4C 38 85                  		jmp PauseLogic
084F3                           	+
084F3 C9 02                     	cmp #2
084F5 D0 03                     	bne +
084F7 4C 69 85                  		jmp InterLogic
084FA                           	+
084FA 4C 6C 85                  	jmp MenuLogic
084FD                           
084FD                           	; Lógica del juego
084FD                           	;
084FD                           	GameplayLogic:
084FD                           		; Logica del jugador 1
084FD                           		; 
084FD                           		
084FD                           		PLY_PhysicsUpdate 0 				; Físicas del jugador 1
084FD                           	; Mueve al jugador horizontalmente dependiendo del input
084FD                           	; Si acaba de hacer un Wall Jump, no acepta input por unos frames
084FD A2 00                     	ldx #0 	; Jugador 1
084FF B5 1C                     	lda player_wjcd,x 				;
08501 D0 03                     	bne + 										;
08503 20 C9 81                  		jsr PLY_JoyAccelerateAxis
08506                           	+
08506 A2 00                     	ldx #0	; Jugador 1
08508                           	MOVE_ApplyVelocityAxisSub player_x,player_xsub,player_xv,player_xvsub
08508 18                        	clc 						;
08509 B5 13                     	lda player_xsub,x 	;
0850B 65 17                     	adc player_xvsub 		;
0850D 95 13                     	sta player_xsub,x 	;
0850F B5 12                     	lda player_x,x 			;
08511 65 16                     	adc player_xv 				;
08513 95 12                     	sta player_x,x 			;
08515                           	
08515                           	;Que no se pase del extremo izquierdo
08515 A2 00                     	ldx #0 	; Jugador 1
08517 B5 12                     	lda player_x,x
08519 C9 05                     	cmp #5
0851B 30 08                     	bmi + 				; si player_x está entre 5 y 7:
0851D C9 07                     	cmp #7
0851F 10 04                     	bpl +
08521 A9 08                     		lda #8			; pone al player en la posición 8 en X
08523 95 12                     		sta player_x,x
08525                           	+
08525                           
08525                           	;Chequea colisión con mapa de tiles. Eje X
08525 A2 00                     	ldx #0 		; Jugador 1
08527 A9 00                     	lda #0						; Resetea las flags de si está tocando las paredes
08529 95 1B                     	sta player_wall,x 	;
0852B 20 8B 82                  	jsr PLY_CheckWallsX
0852E                           
0852E                           	;Maneja la gravedad y el salto del jugador
0852E A2 00                     	ldx #0 		; Jugador 1
08530 20 04 84                  	jsr PLY_JumpFall	;
08533                           	
08533                           	; Chequea colisión con mapa de tiles. Eje Y
08533 A2 00                     	ldx #0						; Jugador 1
08535 20 45 83                  	jsr PLY_CheckWallsY
08538                           		
08538                           		; No deja que se pase de la parte superior del nivel
08538                           		;lda player_y
08538                           		;cmp #32 						;Y=32: parte superior del nivel, parte inferior del HUD
08538                           		;bpl + 							; si player_y es menor a 32,
08538                           		;cmp #24 						; y mayor a 24:
08538                           		;bmi + 							;
08538                           		;	lda #32 					; acomoda player_y en 32.
08538                           		;	sta player_y			;
08538                           		;	lda #0						;resetea la velocidad vertical.
08538                           		;	sta player_yv 		;
08538                           		;	sta player_yvsub	;
08538                           		;	sta player_ysub 	;
08538                           		;+
08538                           	
08538                           	; Cosas que se procesan aún cuando está pausado
08538                           	;
08538                           	PauseLogic:
08538                           		; Chequea si acaba de presionar el botón Start
08538                           		IO_CheckButton 1,JP_START,1
08538 A5 0B                     	lda joypad1 + (1 - 1)*2
0853A 29 10                     	and #JP_START
0853C F0 04                     	beq @end
0853E                           	IF 1
0853E 45 0C                     		eor joypad1_prev + (1 - 1)*2
08540 29 10                     		and #JP_START
08542                           	ENDIF
08542                           	@end:
08542 C9 00                     	cmp #0
08544                           	; Regresa el estado de la flag "Zero"
08544                           	; También deja el estado del botón en A.
08544                           	; (A == 0: Falso -- A != 0: Verdadero)
08544 F0 06                     		beq +
08546 A5 0F                     			lda game_state
08548 49 01                     			eor #1 		; Togglea el estado de pausa
0854A 85 0F                     			sta game_state
0854C                           		+
0854C                           		; antes de finalizar el frame
0854C                           		; posicion del jugador 1
0854C A6 12                     		ldx player_x
0854E A4 14                     		ldy player_y
08550 88                        		dey 							; sube Y un píxel para acomodar la posición del sprite
08551 8E 07 02                  		stx PLAYER_1_SPR+SPRINFO_X
08554 8C 04 02                  		sty PLAYER_1_SPR+SPRINFO_Y
08557                           		; posicion del jugador 2
08557 A5 10                     		lda two_players
08559 F0 0B                     		beq +
0855B A6 1E                     			ldx player2_x
0855D A4 20                     			ldy player2_y
0855F 88                        			dey 							; sube Y un píxel para acomodar la posición del sprite
08560 8E 0B 02                  			stx PLAYER_2_SPR+SPRINFO_X
08563 8C 08 02                  			sty PLAYER_2_SPR+SPRINFO_Y
08566                           		+
08566 4C 82 85                  	jmp FrameEnd
08569                           	
08569                           	
08569                           	; Lógica de intermission
08569                           	;
08569                           	InterLogic:
08569                           	; ...
08569 4C 82 85                  	jmp FrameEnd
0856C                           	
0856C                           	
0856C                           	; Logica del menú
0856C                           	;
0856C                           	MenuLogic:
0856C                           	IO_CheckButton 1,JP_START,1
0856C A5 0B                     	lda joypad1 + (1 - 1)*2
0856E 29 10                     	and #JP_START
08570 F0 04                     	beq @end
08572                           	IF 1
08572 45 0C                     		eor joypad1_prev + (1 - 1)*2
08574 29 10                     		and #JP_START
08576                           	ENDIF
08576                           	@end:
08576 C9 00                     	cmp #0
08578                           	; Regresa el estado de la flag "Zero"
08578                           	; También deja el estado del botón en A.
08578                           	; (A == 0: Falso -- A != 0: Verdadero)
08578 F0 08                     	beq +
0857A                           		; lda #GAME_STATE_GAMEPLAY
0857A                           		; sta game_state 
0857A 20 7F 81                  		jsr GAME_LoadLevel
0857D                           	  ; --- Inicializa jugador/es ---
0857D                           	  ; Esto debe hacerse al iniciar un nivel
0857D                           	  ; Player 1
0857D A2 00                     	  ldx #0	; Variables del jug 1
0857F 20 AC 81                  	  jsr PLY_Spawn
08582                           	  ; Player 2 (sólo si el modo 2 players está activado)
08582                           	  ; lda two_players
08582                           	  ; beq +
08582                           	  ; 	ldx #PLY_DATA_OFFSET ; Variables del jug 2
08582                           	  ; 	jsr PLY_Spawn
08582                           	  ; +
08582                           	+
08582                           	
08582                           	; Final del frame
08582                           	;
08582                           	FrameEnd:
08582                           	
08582                           	; Una vez ejecutada toda la lógica durante el frame, esperamos a que la PPU se desocupe y nos
08582                           	; interrumpa para poder actualizar los gráficos.
08582 E6 0A                     	inc waiting_nmi
08584                           	@wait:
08584 A5 0A                     		lda waiting_nmi
08586 D0 FC                     		bne @wait 			;Entramos en un Loop infinito hasta que la PPU esté lista. Entonces saltaremos a "NMI:"
08588                           		; Cuando finalice la rutina de VBLANK (cuando finalice "NMI:"), volveremos aquí.
08588 4C B7 84                  jmp main_loop 			;volveremos a procesar toda la lógica para el siguiente frame.
0858B                           
0858B                           
0858B                           ; # - - - - - - - - - - - - - - - - - - - - - - - - - - #
0858B                           ; # - - - Sub-Rutinas del Juego (Funciones) - - - - - - #
0858B                           ; # - - - - - - - - - - - - - - - - - - - - - - - - - - #
0858B                           
0858B                           
0858B                           
0858B                           ; # - - - - - - - - - - - - - - - - - - - - #
0858B                           ; # - - -     Binarios externos     - - - - #
0858B                           ; # - - - - - - - - - - - - - - - - - - - - #
0858B 00 00 00 00 00 00 00 00.. .align 256
08600                           ; Información de fondo + atributos de color
08600                           bg:
08600 00 00 00 00 00 00 00 00.. .incbin "res\pantalla.nam"	;(tamaño: 1024 Bytes)
08A00                           BG_MenuScreen:
08A00 30 30 30 30 30 30 30 30.. .incbin "res\menu.nam"	; (1024 bytes)
08E00                           
08E00                           metatiles:
08E00                           .include "res\metatiles.asm"	; (64 bytes)
08E00                           ; Lista de metatiles
08E00                           ; +0 | +1
08E00                           ; ---+---
08E00                           ; +2 | +3
08E00                           
08E00                           ; BLOCK Type (0 - 7)
08E00 00 00 00 00               .byte $00, $00, $00, $00	; Tile $00
08E04 FF 00 00 00               .byte $FF, $00, $00, $00	; Tile $01
08E08 FF FF 00 00               .byte $FF, $FF, $00, $00	; Tile $02
08E0C FF 00 FF 00               .byte $FF, $00, $FF, $00	; Tile $03
08E10 FF FF FF 00               .byte $FF, $FF, $FF, $00	; Tile $04
08E14 00 00 FF FF               .byte $00, $00, $FF, $FF	; Tile $05
08E18 00 FF 00 FF               .byte $00, $FF, $00, $FF	; Tile $06
08E1C FF FF FF FF               .byte $FF, $FF, $FF, $FF	; Tile $07
08E20                           
08E20                           ; Background Type (8 - 255)
08E20 72 73 74 00               .byte $72, $73, $74, $00	; Tile $08 - Lab wall
08E24 79 7A 7D 7E               .byte $79, $7A, $7D, $7E	; Tile $09 - Tube Base
08E28 77 78 79 7A               .byte $77, $78, $79, $7A	; Tile $0A - Tube Top
08E2C 71 76 75 00               .byte $71, $76, $75, $00	; Tile $0B - Pipe Joint
08E30 76 76 00 00               .byte $76, $76, $00, $00	; Tile $0C - Pipe Horiz
08E34 75 00 75 00               .byte $75, $00, $75, $00	; Tile $0D - Pipe Vert
08E38 00 00 7B 0C               .byte $00, $00, $7B, $0C	; Tile $0E - Tube Top Broken
08E3C 7D 7E 7D 7E               .byte $7D, $7E, $7D, $7E	; Tile $0F - Tank..? (two tube bases stacked)
08E40                           
08E40 00 00 00 00 00 00 00 00.. .align 256
08F00                           
08F00                           coll: 		;informacion de colision del nivel (120 bytes)
08F00 00 00 00 00               .byte %00000000, %00000000, %00000000, %00000000
08F04 00 00 00 00               .byte %00000000, %00000000, %00000000, %00000000
08F08 00 00 00 00               .byte %00000000, %00000000, %00000000, %00000000
08F0C 00 00 00 00               .byte %00000000, %00000000, %00000000, %00000000
08F10 00 00 00 00               .byte %00000000, %00000000, %00000000, %00000000
08F14 00 00 00 00               .byte %00000000, %00000000, %00000000, %00000000
08F18 00 00 00 00               .byte %00000000, %00000000, %00000000, %00000000
08F1C 00 00 00 00               .byte %00000000, %00000000, %00000000, %00000000
08F20 3F FF FF F8               .byte %00111111, %11111111, %11111111, %11111000
08F24 20 00 00 08               .byte %00100000, %00000000, %00000000, %00001000
08F28 20 00 00 E8               .byte %00100000, %00000000, %00000000, %11101000
08F2C 20 00 00 28               .byte %00100000, %00000000, %00000000, %00101000
08F30 20 00 00 28               .byte %00100000, %00000000, %00000000, %00101000
08F34 20 00 00 28               .byte %00100000, %00000000, %00000000, %00101000
08F38 20 00 00 2F               .byte %00100000, %00000000, %00000000, %00101111
08F3C 20 00 00 00               .byte %00100000, %00000000, %00000000, %00000000
08F40 20 00 00 00               .byte %00100000, %00000000, %00000000, %00000000
08F44 20 00 00 00               .byte %00100000, %00000000, %00000000, %00000000
08F48 3F E0 FF FF               .byte %00111111, %11100000, %11111111, %11111111
08F4C 00 20 80 00               .byte %00000000, %00100000, %10000000, %00000000
08F50 00 20 80 00               .byte %00000000, %00100000, %10000000, %00000000
08F54 00 20 80 00               .byte %00000000, %00100000, %10000000, %00000000
08F58 00 20 FF FE               .byte %00000000, %00100000, %11111111, %11111110
08F5C 00 20 00 02               .byte %00000000, %00100000, %00000000, %00000010
08F60 00 20 00 02               .byte %00000000, %00100000, %00000000, %00000010
08F64 00 20 00 02               .byte %00000000, %00100000, %00000000, %00000010
08F68 00 20 F8 02               .byte %00000000, %00100000, %11111000, %00000010
08F6C 00 20 88 02               .byte %00000000, %00100000, %10001000, %00000010
08F70 00 20 8F FE               .byte %00000000, %00100000, %10001111, %11111110
08F74 00 20 80 00               .byte %00000000, %00100000, %10000000, %00000000 
08F78                           
08F78 00 00 00 00 00 00 00 00   .align 16
08F80                           ; paletas de fondo y de sprites respectivamente
08F80                           palette:
08F80 0F 2D 10 20 0F 0B 1B 2B.. .incbin "res\paleta_s1b.pal"			;Colores para el fondo del sector 1.	(16 bytes)
08F90 0F 07 16 26 0F 18 28 38.. .incbin "res\paleta_sprites.pal"	;Colores para los diferentes objetos móviles(sprites). (16 bytes)
08FA0                           
08FA0                           ; Datos del sprite de ogmo
08FA0                           sprite_ogmo:
08FA0 00 01 00 00               	.byte $00,$01,$00,$00
08FA4                           
08FA4                           ; # - - - - - - - - - - - - - - - - - - - - #
08FA4                           ; # - - -         Vectores            - - - #
08FA4                           ; # - - - - - - - - - - - - - - - - - - - - #
08FA4                           
08FA4                           ; Define los vectores del procesador apuntando a las respectivas etiquetas.
08FA4 00 00 00 00 00 00 00 00.. .pad $FFFA
0FFFA                           
0FFFA CC 80 51 80 EA 80         .word NMI, RESET, IRQ
10000                           ;indicamos al procesador a qué dirección tiene que saltar en caso de un Interrupt o Reset
10000                           
10000                           ; ( Fin de la PRG-ROM )
10000                           
10000                           ; # - - - - - - - - - - - - - - - - - - - - #
10000                           ; # - - -     CHR-ROM(Gráficos)       - - - #
10000                           ; # - - - - - - - - - - - - - - - - - - - - #
10000                           
10000                           ; Importar binario con los Gráficos de la CHR-ROM
10000 00 00 00 00 00 00 00 00.. .incbin "res\caracteres.chr"		;(tamaño: 8192 Bytes)
12000                           
12000                           ; ( Fin de la CHR-ROM )
